 % !TEX program = xelatex
\documentclass[12pt]{extarticle}
\usepackage[T1]{fontenc}
\usepackage{fontspec}

\defaultfontfeatures{Ligatures=TeX}
\setmainfont{Noto Serif}
\setsansfont{Noto Sans}
\setmonofont{Noto Sans Mono}

\usepackage[bulgarian,english]{babel}
\usepackage{indentfirst}
\usepackage[a4paper, portrait, margin = 2.5 cm]{geometry}
\usepackage{url}
\usepackage{color}
\usepackage{xcolor}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{adjustbox}
\usepackage{listings}
\usepackage{syntax}
\renewcommand{\baselinestretch}{1.1}
\setlength{\emergencystretch}{3em}
\setlength{\parskip}{5pt}
\setlength{\parindent}{0pt}


\lstset{
	backgroundcolor = \color{light-gray},
    language = C,
    xleftmargin = 1cm,
    framexleftmargin = 1em,
    basicstyle=\ttfamily,
	moredelim=[is][\underbar]{_}{_},
}

\newcommand\restr[2]{{% we make the whole thing an ordinary symbol
  \left.\kern-\nulldelimiterspace % automatically resize the bar with \right
  #1 % the function
  \vphantom{\big|} % pretend it's a little taller at normal size
  \right|_{#2} % this is the delimiter
  }}

\usepackage{color}
\definecolor{Bluish}{rgb}{0.39,0.55,0.78}
\definecolor{light-gray}{gray}{0.9}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linktoc=all,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\usepackage{tabularx}


\setlength{\grammarparsep}{20pt plus 1pt minus 1pt} % increase separation between rules
\setlength{\grammarindent}{12em} % increase separation between LHS/RHS

\theoremstyle{definition} \newtheorem{defn}{Definition}
\theoremstyle{definition} \newtheorem{prop}{Proposition}

\newcommand{\lc}{\textcolor{red}{\backslash}}
\newcommand{\rc}{\textcolor{red}{/}}
\newcommand{\mc}{\textcolor{red}{|}}
\newcommand{\lb}{\textcolor{red}{[}}
\newcommand{\rb}{\textcolor{red}{]}}
\newcommand{\lp}{\textcolor{red}{(}}
\newcommand{\rp}{\textcolor{red}{)}}

\title{ble ble}
\author{Ангел Ангелов <dexterlb@qtrp.org>}
\date{2018}

\begin{document}
% uncomment for fancy title:
% \maketitle
% \thispagestyle{empty}
% \tableofcontents
% \pagebreak

\section{Pure CCG}
The CCG formalism is used in a multitude of variants. The form presented here
will be most basic and of little practical use: it will only allow composition
rules and the only restriction will be a global maximum arity.

This is enough for understanding the parsing algorithms, and can be further
extended to include features such as type-raising,
arbitrary rule restrictions, slash modalities,
category features, category variables and feature variables.

\begin{defn}
    For a set $\tau$, its \emph{categorial closure} $C(\tau)$ is defined as follows:
    \begin{enumerate}
        \item \label{itm:atomic} $A \in \tau \Rightarrow A \in C(\tau)$
        \item \label{itm:right}  $X, Y \in C(\tau) \Rightarrow \lp X \rc Y \rp \in C(\tau)$
        \item \label{itm:left}   $X, Y \in C(\tau) \Rightarrow \lp X \lc Y \rp \in C(\tau)$
    \end{enumerate}

    Letters like $A, B, C$ will be used to denote atomic categories (produced
    by rule \ref{itm:atomic}), while letters like $X, Y, Z$ will be used to
    denote complex categories (produced by rules \ref{itm:left} and \ref{itm:right}).

    Such expressions are called \emph{categories}. The $\mc$ symbol will be
    used to denote any slash (when the distinction between $\lc$ and $\rc$
    doesn't matter). Categories will also be considered left-associative.
    Thus we can write $X_1 \mc X_2 \mc X_3 \mc X_4$ to denote
    $\lp \lp \lp X_1 \mc X_2 \rp \mc X_3 \rp \mc X_4 \rp$. It's useful to note that $X_1$ may
    be decomposed into its constituents until it becomes an atomic category:
    this means that every category can be written in the form
    $A \mc X_1 \mc X_2 \mc ... \mc X_n$, where $A$ is atomic. We say that
    $n$ is the category's \emph{arity}. $A$ is called its \emph{target} or
    return type, while
    $X_1 ... X_n$ are called its \emph{arguments} or argument types.

    For any string $\alpha \in (\lb C(\tau) \rb \cup \Sigma)^*$, where $\Sigma$ is a
    finite set, we define $C(\alpha)$ to be the set of all categories which
    can be found in $\alpha$, namely:
    \begin{itemize}
        \item $C(\varepsilon) = \emptyset$
        \item for $a \in \Sigma$, $C(a\beta) = C(\beta)$
        \item for $X \in C(\tau)$, $C(\lb X \rb \beta) = X \cup C(\beta)$
    \end{itemize}
\end{defn}

\begin{defn}
    $ G = \langle \Sigma, N, S, f, n \rangle $ is a \emph{Combinatory Categorial Grammar}, where
    \begin{itemize}
        \item $ \Sigma $ is the set of \emph{terminals}
        \item $ N $ is the set of \emph{non-terminals} (atomic categories)
        \item $ S \in N $ is the \emph{target category}
        \item $ f : \Sigma \rightarrow \hat{N} $, where $\hat{N}$ is the set of
            \textbf{finite} subsets of $C(N)$, is the function for interpreting
            terminals
        \item $ n \in \mathbb{N} $ is the \emph{maximum composition arity}
    \end{itemize}
\end{defn}

\pagebreak
\subsection{Derivations}

\begin{defn}
    For a CCG $G$, we can construct a set $R \subset (\lb C(N) \rb) \times (\Sigma \cup \lb C(N) \rb)^*$
    of \emph{rule instances}. Instead of $(\alpha, \beta) \in R$, we will write
    $\alpha \rightarrow \beta$.

    \begin{itemize}
        \item If $ a \in \Sigma, X \in f(a) $, then \[ \lb X \rb \rightarrow a \]
        \item If $ X \rc Y \in C(N), Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m \in C(N), 0 \leq m \leq n $
            then \[ \lb X \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m \rb \rightarrow \lb X \rc Y \rb \lb Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m \rb \]
        \item If $ X \lc Y \in C(N), Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m \in C(N), 0 \leq m \leq n $
            then \[ \lb X \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m \rb \rightarrow \lb Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m \rb \lb X \lc Y \rb \]
    \end{itemize}
\end{defn}

\begin{defn}
    Derivation process
    \begin{itemize}
        \item If $\beta \rightarrow \beta'$, then $\alpha \beta \gamma \Rightarrow \alpha \beta' \gamma$
        \item Let $\Rightarrow^*$ be the reflexive and transitive closure of $\Rightarrow$.
        \item If $\alpha \Rightarrow^* \beta$, we can write
            \[ \mu: \alpha \Rightarrow \alpha_1 \Rightarrow ... \Rightarrow \alpha_r = \beta \]
            and call $\mu$ a \emph{derivation} for $G$. Then $C(\mu) = \bigcup\limits_{i=1}^{r} C(\alpha_i)$
            is the set of all categories used in $\mu$.
        \item $L(G) := \{ \alpha \in \Sigma^* \mid \lb S \rb \Rightarrow^* \alpha \}$
    \end{itemize}
\end{defn}

\begin{prop}
    A CCG $G = \langle \Sigma, N, S, f, n \rangle$ is equivalent to an
    (albeit infinite) context-free grammar
    $G^C = \langle \Sigma, \lb C(N) \rb, R, \lb S \rb \rangle$.

    Moreover, let $\mu: \lb X \rb \Rightarrow \alpha_1 \Rightarrow ... \Rightarrow \alpha_r$
    be a derivation for $G$.
    We can construct a finite context-free grammar
    $G_\mu^C = \langle \Sigma, \lb C(\mu) \rb, \restr{R}{\lb C(\mu) \rb}, \lb S \rb \rangle$
    which produces $\mu$.
\end{prop}
\begin{proof}
    This follows because our definition of $\Rightarrow$ for $G$ and the context-free
    definition of $\Rightarrow$ for $G^C$ are the same.
\end{proof}

\begin{prop}
    Properties of CCG derivation
    \begin{itemize}
        \item $\varepsilon \notin L(G)$
        \item If $\alpha \Rightarrow \alpha', \beta \Rightarrow \beta'$,
              then $\alpha \beta \Rightarrow \alpha' \beta'$
              (\emph{concatenativity})
    \end{itemize}
\end{prop}

\subsection{The CYK algorithm}

This is the most straight-forward algorithm for parsing a string with the help
of CCG. It is easy to understand, but has exponential runtime with respect to
the input word length.

Let $ G = \langle \Sigma, N, S, f, n \rangle $ be a CCG and $w = w_1 ... w_k$
be a word.

The algorithm recursively builds a set $P$ of \emph{items} in the form
$(X, i, j)$, $X \in C(N), 1 \leq i \leq j \leq k$ and aims to produce the item
$(S, 1, k)$.

\begin{enumerate}
    \item If $X \in f(w_i)$, then $(X, i, i) \in P$
    \item If $(X \rc Y, i, p) \in P, (Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m, p + 1, j) \in P, 1 \leq i \leq p < j \leq k, 0 \leq m \leq n$,
        then $(X \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m, i, j) \in P$
    \

        Moreover, item If $(X \lc Y, p + 1, j) \in P, (Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m, i, p) \in P, 1 \leq i \leq p < j \leq k, 0 \leq m \leq n$,
        then $(X \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m, i, j) \in P$
\end{enumerate}

To reason about the algorithm, we will use the following invariant:
\begin{equation}
    \lb X \rb \Rightarrow^* w_i ... w_j \iff (X, i, j) \in P
\end{equation}

\begin{prop}
    The algorithm is \textbf{correct}: if $(S, 1, k) \in P$, then $w \in L(G)$.
\end{prop}
\begin{proof}
    We have to prove the right-to-left direction of the invariant:
    \begin{equation}\label{eq:left}
        (X, i, j) \in P \implies \lb X \rb \Rightarrow^* w_i ... w_j
    \end{equation}

    From which would follow $ (S, 1, k) \in P \implies \lb S \rb \Rightarrow^* w_1 ... w_k$,
    which is what we need to prove.

    So, let $(X, i, j) \in P$ and inductively suppose that (\ref{eq:left}) is true
    for any shorter substrings of $w$. There are 3 rules by which this item has appeared:
    \begin{enumerate}
        \item $i = j, X \in f(w_i)$: This means
            $\lb X \rb \rightarrow w_i \implies \lb X \rb \Rightarrow^* w_i = w_i ... w_j$
        \item \label{itm:rightslash} $i < j$ and
            \begin{itemize}
                \item $X = W \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m$
                \item $(W \rc Y, i, p) \in P$
                \item $(Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m, p + 1, j) \in P$
            \end{itemize}
            for some $i \leq p < j, m \leq n$. By inductive hypothesis,
            $\lb W \rc Y \rb \Rightarrow^* w_i ... w_p$
            and
            $\lb Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m \rb \Rightarrow^* w_{p + 1} ... w_j$.
            Then, by the definition of $\rightarrow$ and by concatenativity of
            $\Rightarrow$, we have:
            \[
                \lb X \rb = \lb W \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m \rb
                \rightarrow
                \lb W \rc Y \rb \lb Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m \rb
                \Rightarrow^*
                w_i ... w_p w_{p + 1} ... w_j = w
            \]
        \item $i < j$ and (analogous to \ref{itm:rightslash})
            \begin{itemize}
                \item $X = W \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m$
                \item $(W \lc Y, p + 1, j) \in P$
                \item $(Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m, i, p) \in P$
            \end{itemize}
            for some $i \leq p < j, m \leq n$. By inductive hypothesis,
            $\lb W \rc Y \rb \Rightarrow^* w_{p + 1} ... w_j$
            and
            $\lb Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m \rb \Rightarrow^* w_i ... w_p$.
            Then, by the definition of $\rightarrow$ and by concatenativity of
            $\Rightarrow$, we have:
            \[
                \lb X \rb = \lb W \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m \rb
                \rightarrow
                \lb Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m \rb \lb W \lc Y \rb
                \Rightarrow^*
                w_i ... w_p w_{p + 1} ... w_j = w
            \]
    \end{enumerate}
\end{proof}

\begin{prop}
    The algorithm is \textbf{complete}: if $w \in L(G)$, then $(S, 1, k) \in P$.
\end{prop}
\begin{proof}
    We have to prove the left-to-right direction of the invariant:
    \begin{equation}\label{eq:right}
        \lb X \rb \Rightarrow^* w_i ... w_j \implies (X, i, j) \in P
    \end{equation}
    From which would follow $ \lb S \rb \Rightarrow^* w_1 ... w_k \implies (S, 1, k) \in P$,
    which is what we need to prove.

    Let $\mu: \lb X \rb \Rightarrow \alpha \Rightarrow^* w_i ... w_j$
    be a derivation for $G$. We will prove (\ref{eq:right}) by induction over
    $\mu$ from right to left.

    The only way for $\lb X \rb$ to appear to the left
    of a production is $\lb X \rb \rightarrow \alpha$ - we can now look at
    all ways for this to happen.
    \begin{enumerate}
        \item $\alpha = a \in \Sigma, X \in f(a)$. Then $w = \alpha, i = j, w_i = a$,
            which means $(X, i, i) = (X, i, j) \in P$.
        \item $X = W \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m$ and
            $\alpha = \lb W \rc Y \rb \lb Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m \rb$.
            Since $\mu$ is also a derivation in the context-free
            grammar $G^C_{\mu}$ where $\lb W \rc Y \rb$ and $\lb Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m \rb$
            are non-terminals, there exists $p$ such that
            \begin{itemize}
                \item $\lb W \rc Y \rb \Rightarrow^* w_i ... w_p$
                \item $\lb Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m \rb \Rightarrow^* w_{p+1} ... w_j$
            \end{itemize}
            However, according to the inductive hypothesis, this means that
            $(W \rc Y, i, p) \in P$ and
            $(Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m, p + 1, j) \in P$. Thus,
            by the algorithm definition,
            $(X = W \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m, i, j) \in P$.
        \item (analogous) $X = W \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m$ and
            $\alpha = \lb Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m \rb \lb W \lc Y \rb$.
            Since $\mu$ is also a derivation in the context-free
            grammar $G^C_{\mu}$ where $\lb W \lc Y \rb$ and $\lb Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m \rb$
            are non-terminals, there exists $p$ such that
            \begin{itemize}
                \item $\lb Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m \rb \Rightarrow^* w_i ... w_p$
                \item $\lb W \rc Y \rb \Rightarrow^* w_{p + 1} ... w_j$
            \end{itemize}
            However, according to the inductive hypothesis, this means that
            $(W \lc Y, p + 1, j) \in P$ and
            $(Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m, i, p) \in P$. Thus,
            by the algorithm definition,
            $(X = W \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m, i, j) \in P$.
    \end{enumerate}

\end{proof}

\subsection{The Vijay-Shanker algorithm}

This algorithm behaves like the CYK algorithm for derivations which use only
short categories. In order to pack longer categories in a way which wouldn't
result in polynomial complexity, it uses some clever tricks.

The algorithm uses two types of items:
\begin{enumerate}
    \item $(A, \alpha, i, j), A \in N, \alpha \in \{ \lc, \rc \} C(N), 1 \leq i \leq j \leq k$
    \item $(A, \alpha, T, i, j, p, q), A \in N, T \in \{ \lc, \rc \} N, \alpha \in \{ \lc, \rc \} C(N), 1 \leq i \leq p \leq q \leq j \leq k$
\end{enumerate}

\end{document}

