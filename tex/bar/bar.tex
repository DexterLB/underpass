 % !TEX program = xelatex
\documentclass[12pt]{extarticle}
\usepackage[T1]{fontenc}
\usepackage{fontspec}

\defaultfontfeatures{Ligatures=TeX}
\setmainfont{Noto Serif}
\setsansfont{Noto Sans}
\setmonofont{Noto Sans Mono}

\usepackage[bulgarian,english]{babel}
\usepackage{indentfirst}
\usepackage[a4paper, portrait, margin = 2.5 cm]{geometry}
\usepackage{url}
\usepackage{color}
\usepackage{xcolor}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{adjustbox}
\usepackage{listings}
\usepackage{syntax}
\renewcommand{\baselinestretch}{1.1}
\setlength{\emergencystretch}{3em}
\setlength{\parindent}{0pt}


\lstset{
	backgroundcolor = \color{light-gray},
    language = C,
    xleftmargin = 1cm,
    framexleftmargin = 1em,
    basicstyle=\ttfamily,
	moredelim=[is][\underbar]{_}{_},
}

\usepackage{color}
\definecolor{Bluish}{rgb}{0.39,0.55,0.78}
\definecolor{light-gray}{gray}{0.9}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linktoc=all,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\usepackage{tabularx}


\setlength{\grammarparsep}{20pt plus 1pt minus 1pt} % increase separation between rules
\setlength{\grammarindent}{12em} % increase separation between LHS/RHS

\theoremstyle{definition} \newtheorem{defn}{Definition}

\newcommand{\lc}{\backslash}
\newcommand{\rc}{/}
\newcommand{\mc}{|}
\newcommand{\lb}{[}
\newcommand{\rb}{]}

\title{ble ble}
\author{Ангел Ангелов <dexterlb@qtrp.org>}
\date{2018}

\begin{document}
% uncomment for fancy title:
% \maketitle
% \thispagestyle{empty}
% \tableofcontents
% \pagebreak

\section{Pure CCG}
The CCG formalism is used in a multitude of variants. The form presented here
will be most basic and of little practical use: it will only allow composition
rules and the only restriction will be a global maximum arity.

This is enough for understanding the parsing algorithms, and can be further
extended to include features such as type-raising,
arbitrary rule restrictions, slash modalities,
category features, category variables and feature variables.

\begin{defn}
    For a set $\tau$, its \emph{categorial closure} $C(\tau)$ is defined as follows:
    \begin{enumerate}
        \item \label{itm:atomic} $A \in \tau \Rightarrow A \in C(\tau)$
        \item \label{itm:right}  $X, Y \in C(\tau) \Rightarrow (X \rc Y) \in C(\tau)$
        \item \label{itm:left}   $X, Y \in C(\tau) \Rightarrow (X \lc Y) \in C(\tau)$
    \end{enumerate}

    Letters like $A, B, C$ will be used to denote atomic categories (produced
    by rule \ref{itm:atomic}), while letters like $X, Y, Z$ will be used to
    denote complex categories (produced by rules \ref{itm:left} and \ref{itm:right}).

    Such expressions are called \emph{categories}. The $\mc$ symbol will be
    used to denote any slash (when the distinction between $\lc$ and $\rc$
    doesn't matter). Categories will also be considered left-associative.
    Thus we can write $X_1 \mc X_2 \mc X_3 \mc X_4$ to denote
    $(((X_1 \mc X_2) \mc X_3) \mc X_4)$. It's useful to note that $X_1$ may
    be decomposed into its constitutents until it becomes an atomic category:
    this means that every category can be written in the form
    $A \mc X_1 \mc X_2 \mc ... \mc X_n$, where $A$ is atomic. We say that
    $n$ is the category's \emph{arity}. $A$ is called its \emph{target} or
    return type, while
    $X_1 ... X_n$ are called its \emph{arguments} or argument types.
\end{defn}

\begin{defn}
    For a set $\tau$, the set of \emph{categorial compositions} is:
    \[ \hat{C}(\tau) = (\{ \lb \} C(\tau) \{ \rb \})^* \]
\end{defn}

\begin{defn}
    $ G = \langle \Sigma, N, S, f, n \rangle $ is a \emph{Combinatory Categorial Grammar}, where
    \begin{itemize}
        \item $ \Sigma $ is the set of \emph{terminals}
        \item $ N $ is the set of \emph{non-terminals} (atomic categories)
        \item $ S \in N $ is the \emph{target category}
        \item $ f : \Sigma \rightarrow C(N) $ is the function for interpreting
            terminals
        \item $ n \in \mathbb{N} $ is the \emph{maximum composition arity}
    \end{itemize}
\end{defn}

\subsection{Derivations}

\begin{defn}
    Basic derivation
    \begin{itemize}
        \item If $ a \in \Sigma, X \in f(a) $, then \[ a \rightarrow \lb X \rb \]
        \item If $ X \rc Y \in C(N), Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m \in C(N), m \leq n $
            then \[ \lb X \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m \rb \rightarrow \lb X \rc Y \rb \lb Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m \rb \]
        \item If $ X \lc Y \in C(N), Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m \in C(N), m \leq n $
            then \[ \lb X \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m \rb \rightarrow \lb Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m \rb \lb X \lc Y \rb \]
    \end{itemize}
\end{defn}

\begin{defn}
    Derivation process
    \begin{itemize}
        \item If $\beta \rightarrow \beta'$, then $\alpha \beta \gamma \Rightarrow \alpha \beta' \gamma$
        \item Let $\Rightarrow^*$ be the transitive closure of $\Rightarrow$.
        \item $L(G) := \{ \alpha \in \Sigma^* \mid \lb S \rb \Rightarrow^* \alpha \}$
    \end{itemize}
\end{defn}





\end{document}

