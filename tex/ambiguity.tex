\documentclass[main.tex]{subfiles}
\begin{document}

\subsubsection{Ambiguity, spurious ambiguity and the Eisner normal form}
One of the great problems of grammar systems such as CCG is ambiguity.
By \emph{ambiguity} we mean the phenomenon that a single sentence may be
generated by many different derivation trees.

The simplest type of ambiguity is \emph{lexical ambiguity}, where the given
sentence actually has several meanings.

\begin{example}
    For example, take the query
    \begin{center}
        $memorials$ $near$ $cities$ $in$ $Belgium$
    \end{center}
    With the following simple grammar:

    \gramshort{
        \gramrow{memorials}{ GSet }{}
        \gramrow{cities}{ GSet }{}
        \gramrow{near}{ GSet \lc GSet \rc GSet }{}
        \gramrow{in}{ GSet \lc GSet \rc GSet }{}
    }

    There are two possible derivation trees:

    \centree{.{$GSet$}
        [ .{$GSet$} [ .{$memorials$} ] ]
        [ .{$GSet \lc GSet$}
            [ .{$GSet \lc GSet \rc GSet$} [ .{$near$} ] ]
            [ .{$GSet$}
                [ .{$GSet$} [ .{$cities$} ] ]
                [ .{$GSet \lc GSet$}
                    [ .{$GSet \lc GSet \rc GSet$} [ .{$In$} ] ]
                    [ .{$GSet$} [ .{$Belgium$} ] ]
                ]
            ]
        ]
    }

    This parse means ``memorials which are near cities, said \emph{cities} being
    in Belgium''.

    \centree{.{$GSet$}
        [ .{$GSet$}
            [ .{$GSet$} [ .{$memorials$} ] ]
            [ .{$GSet \lc GSet$}
                [ .{$GSet \lc GSet \rc GSet$} [ .{$near$} ] ]
                [ .{$GSet$} [ .{$cities$} ] ]
            ]
        ]
        [ .{$GSet \lc GSet$}
            [ .{$GSet \lc GSet \rc GSet$} [ .{$In$} ] ]
            [ .{$GSet$} [ .{$Belgium$} ] ]
        ]
    }

    While this parse means ``memorials which are near cities, said \emph{memorials}
    being in Belgium''.

    Both interpretations of the query are valid: a human would also interpret
    the query differently depending on their context and state of mind.
    Nevertheless, the set of objects returned for the two interpretations may
    be different (imagine a memorial just outside the border of Belgium
    that is near a city just inside the border).
\end{example}

The term \emph{spurious ambiguity} within the context of CCG refers to generating
different derivation trees \emph{with the same meaning} for the same sentence. There
is seldom any use in keeping such different trees in memory, so we would like
to be able to leave only one tree for each distinct meaning.

The question is, what is ``meaning''? Unlike Aristotle, we can choose an arbitrary
definition to the word ``meaning'' by defining an equivalence relation between
derivation trees --- a predicate that tells us whether two trees mean the same
thing.

Whenever using derivation trees to generate $\lambda$-terms, it would be most
convenient to test whether they generate $\beta\eta$-equivalent terms. This might
not guarantee the elimination of all semantically equivalent parses (two terms
might be different but "do" the same thing depending on the interpretation)
but will prune a significant part of them.

Since CCG derivations mimic function composition, one of the most common causes
for spurious ambiguity arises from the associativity of composition: different
trees may construct an equivalent $\lambda$-term by performing the same function
compositions but in a different order.

\begin{example}
    Let's look at the query
    \begin{center}
        $small$ $capital$ $cities$
    \end{center}

    With the following simple grammar:
    \gramshort{
        \gramrow{small}{GSet \rc GSet}{small}
        \gramrow{capital}{GSet \rc GSet}{capital}
        \gramrow{cities}{GSet}{cities}
    }
    where $\typeof{small} = GSet \tot GSet$, $\typeof{capital} = GSet \tot GSet$
    and $\typeof{cities} = GSet$.

    Please take note that $small$ (the token) is different from $small$ (the
    $\lambda$-constant with type $GSet \tot GSet$) and similarly for
    $capital$ and $cities$.

    There are two possible derivation trees:
    \begin{center}
        \begin{tikzpicture}[node distance=1mm,sibling distance=1cm,scale=0.9,every node/.style={transform shape}]
            \Tree[
                .\node(outtop){$GSet$};
                    [ .{$GSet \lc GSet$}
                        [ .{$GSet \rc GSet$} [ .\node(inb){$small$}; ] ]
                        [ .{$GSet \rc GSet$} [ .\node(inc){$capital$}; ] ]
                    ]
                    [ .{$GSet$} [ .\node(ina){$cities$}; ] ]
            ]
            \node[boxcolb,fit=(outtop)(ina)(inb)(inc)](outbox){};
            \node[right=of outbox,text=\boxtextb](outlabel){$T_1$};
        \end{tikzpicture}
        \begin{tikzpicture}[node distance=1mm,sibling distance=1cm,scale=0.9,every node/.style={transform shape}]
            \Tree[
                .\node(outtop){$GSet$};
                    [ .{$GSet \rc GSet$} [ .\node(ina){$small$}; ] ]
                    [ .{$GSet$}
                        [ .{$GSet \rc GSet$} [ .\node(inb){$capital$}; ] ]
                        [ .{$GSet$} [ .\node(inc){$cities$}; ] ]
                    ]
            ]
            \node[boxcolb,fit=(outtop)(ina)(inb)(inc)](outbox){};
            \node[right=of outbox,text=\boxtextb](outlabel){$T_2$};
        \end{tikzpicture}
    \end{center}
    Where by the definition of $sem_\psi$:
    \begin{align*}
        (\lambda x {:} GSet \abstr capital \app (small \app x))
            \app cities & \in sem_{\psi}(T_1) \\
        small \app capital \app cities & \in sem_\psi(T_2) \\
    \end{align*}

    However, $sem_\psi(T_1)$ can also be $\beta$-reduced to
    $small \app (capital \app cities)$, so these two trees can be said to
    be a result of spurious ambiguity.
\end{example}

Most works that try to mitigate "spurious ambiguity" refer to this particular
kind of spurious ambiguity --- the kind arising from composition order.

A construction that completely eliminates compositional spurious ambiguity
within pure CCG is Eisner Normal form \cite{eisner}, which has been further
refined by Hockenmaier et al. \cite{julia} to support most extensions shown
in \cref{sec:hacks} to various extents.

Since spurious ambiguity has not posed a significant problem for the grammars used
in this thesis, this construction, while easy to implement, will not be
discussed further.
\end{document}
