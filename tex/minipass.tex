\documentclass[main.tex]{subfiles}
\begin{document}

\subsection{The Intermediate Language (Minipass)}
\label{sec:minipass}

Overpass is a relatively complex language with assignment, sequentiality
and specialised syntax. As such, it is not well-suited for performing
AST transofmations.

Minipass addresses this problem: its goal is to be easy to manipulate
and reason about, and be translatable to Overpass. It is based on the typed
lambda calculus variant described in \ref{sec:lambda} and speaks about a
world much simpler than the one described by Overpass - a directed graph
with labeled edges and vertices.

The graph abstraction works as follows:
\begin{itemize}
    \item Overpass objects (nodes, ways, relations, areas) are regarded as
        vertices
    \item Object tags are encoded into vertex labels - for example, we
        may have a label for "named London" or "is a cafe".
    \item Edges labels represent relations between objects: for example,
        we may have an edge which means "nearby" or an edge "on the same
        transport route"
\end{itemize}


Minipass consists of the following set of constants and basic types:

\begin{lstlisting}
-- basic types
Num, String     -- self explanatory
List            -- list of Nums, Strings or Lists
Set             -- represents a set of Overpass objects
                -- (nodes, ways, relations, areas)

-- constants
<stringliteral> : String
<numberliteral> : Num

and       : Set -> Set -> Set   -- set intersection
or        : Set -> Set -> Set   -- set union
not       : Set -> Set          -- set negation

get       : List -> Set         -- get elements by label
next      : List -> Set -> Set  -- traverse edges

-- constructing lists
empty       :                     List
consNum     : Num      -> List -> List
consString  : String   -> List -> List
consList    : List     -> List -> List

\end{lstlisting}



Let our world be a directed graph whose vertices we call \emph{elements}.
Each \emph{edge} carries a \emph{label}. Each \emph{label} is a heterogenous
\emph{List} of \emph{Numbers}, \emph{Strings} and other \emph{Lists}.

For ease of writing, let us consider that types are right-associative,
applications are left-associative and that we can write list literals
within square brackets:
\begin{lstlisting}
[42, "foo"] := consNum 42 (consString "foo" empty)
\end{lstlisting}

And here are the types for all constants:


With this abstraction, we can represent most of the Overpass queries for
constructing sets (filters, recurse, in/is_in, set operations, conditions)
by encoding them as labels. Here are some examples:

\begin{lstlisting}
within : Num -> Set -> Set
    := lambda dist { next ["around", dist] }

onStreet : String -> Set
    := lambda str  { next [
        "tagFilter", ["==", "addr:street", str]] }
\end{lstlisting}

\end{document}

