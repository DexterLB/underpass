\documentclass[main.tex]{subfiles}
\begin{document}

\subsection{The Intermediate Language (Minipass)}
\label{sec:minipass}
Overpass is a relatively complex language with assignment, sequentiality
and specialised syntax. As such, it is not well-suited for performing
AST transofmations.

Minipass addresses this problem: its goal is to be easy to manipulate
and reason about, and be translatable to Overpass. It is based on the typed
lambda calculus variant described in \ref{sec:lambda} and speaks about a
world much simpler than the one described by Overpass - a directed graph
with labeled edges and vertices.

The graph abstraction works as follows:
\begin{itemize}
    \item Overpass objects (nodes, ways, relations, areas) are regarded as
        vertices
    \item Object tags are encoded into vertex labels - for example, we
        may have a label for "named London" or "is a cafe".
    \item Edges labels represent relations between objects: for example,
        we may have an edge which means "nearby" or an edge "on the same
        transport route"
\end{itemize}

\subsubsection{Language grammar}
\label{minipass:grammar}
Here is a BNF grammar for the intermediate language.
\begin{grammar}
    <term-definition>  ::= <identifier> `:=' <term>

    <type-definition>  ::= <identifier> `<' <type>

    <type> ::= <simple-type> | <type> <arrow> <simple-type>

    <simple-type> ::= <identifier> | `*' | `(' <type> `)'

    <arrow> ::= `->'

    <term> ::= <nonapp-term> | <nonapp-term> <term>

    <nonapp-term> ::= <constant> | <variable> | <constr> | <abstr> | `(' <term> `)'

    <constant> ::= <identifier>

    <variable> ::= <identifier>

    <constr> ::= <type> `[' <term> `]'

    <abstr> ::= <lambda> <declaration> `=>' <term>

    <lambda> ::= `\\' | `lambda'

    <declaration> ::= <variable> | <variable> `:' <type>

    <filepath> ::= <quoted-string>
\end{grammar}

Note that Minipass is characterised by its predefined constants and basic
types. Because of the modular architecture of the implementation, they can be
replaced by something else, allowing to target a different intermediate language.

\subsubsection{Builtins and base types}
Since Minipass is built on top of $\lambda$-calculus syntax, all built-in
"functions" are actually \emph{constants} in the context of $\lambda$-terms.

The base types are:
\begin{center}
    \begin{tabular}{r p{0.7\textwidth}}
        \code{Num} & represents a floating point number. \cendrow
        \code{String} & represents a string of unicode characters. \cendrow
        \code{List} & represents a linked list of \code{Num}s, \code{String}s and
            nested \code{List}s. \cendrow
        \code{Set} & refers to a set of geographical objects. It is not represented
            internally in any way: the only way to touch \code{Set} objects is
            via builtin operations that work on \code{Set}s. \cendrow
    \end{tabular}
\end{center}

The builtin identifiers (which act as constants in $\lambda$-terms) are the
following:
\begin{center}
    \begin{tabular}{r l p{0.5\textwidth}}
        Identifier  & Type & \\
        \hline
        \code{and}  & $Set \tot Set \tot Set$ & set intersection \cendrow
        \code{or}   & $Set \tot Set \tot Set$ & set union \cendrow
        \code{not}  & $Set \tot Set$ & set negation \cendrow
        \hline
        \code{get}  & $List \tot Set$ & get geographical elements by vertex
            label \cendrow
        \code{next} & $List \tot Set \tot Set$ & traverse edges by label,
            obtaining a new \code{Set} \cendrow
        \hline
        \code{empty} & $List$ & empty list \cendrow
        \code{consNum} & $Num \tot List \tot List$ & prepend a \code{Num} to
            a list \cendrow
        \code{consString} & $String \tot List \tot List$ & prepend a \code{String} to
            a list \cendrow
        \code{consList} & $List \tot List \tot List$ & prepend a \code{List} to
            a list (prepends the list itself, not its elements)\cendrow
    \end{tabular}
\end{center}

\subsubsection{Defining types}
\fixme{write this}

\subsubsection{Defining terms}
\fixme{write this}

\subsubsection{A "standard" library}
\fixme{remove junk, reformat}

Let our world be a directed graph whose vertices we call \emph{elements}.
Each \emph{edge} carries a \emph{label}. Each \emph{label} is a heterogenous
\emph{List} of \emph{Numbers}, \emph{Strings} and other \emph{Lists}.

For ease of writing, let us consider that types are right-associative,
applications are left-associative and that we can write list literals
within square brackets:
\begin{lstlisting}
[42, "foo"] := consNum 42 (consString "foo" empty)
\end{lstlisting}

And here are the types for all constants:


With this abstraction, we can represent most of the Overpass queries for
constructing sets (filters, recurse, in/is_in, set operations, conditions)
by encoding them as labels. Here are some examples:

\begin{lstlisting}
within : Num -> Set -> Set
    := lambda dist { next ["around", dist] }

onStreet : String -> Set
    := lambda str  { next [
        "tagFilter", ["==", "addr:street", str]] }
\end{lstlisting}

\end{document}

