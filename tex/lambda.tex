\documentclass[main.tex]{subfiles}
\begin{document}

\subsection{Simply typed $\lambda$-calculus}
\label{sec:lambda}

For representing compositional terms, a version of simply typed lambda calculus
will be used.

\subsubsection{Types}
\begin{defn}
    A \emph{partial meet-semilattice} is a pair $\langle X, \less \rangle$ where:
    \begin{itemize}
        \item $\less$ is a partial-order relation
        \item for any $x, y \in X$, there is at most one $z$ such that
        \[  z \less x, z \less y,
            \forall t \in X (t \less x, t \less y \implies t \less z) \]
        We can define the partial function $\meet : X \times X \leadsto X$ to
        be $x \meet y = z$ for any $x, y, z$ satisfying this condition.
    \end{itemize}
\end{defn}

\begin{defn}
    Let $\mathbb{T}$ be an infinitely countable set of items we call
    \emph{type symbols}.

    For obvious reasons we want $(\{ \tot, ), ( \} \cup \mathbb{T})^*
    \cap \mathbb{T} = \emptyset$.
\end{defn}

\begin{defn}
    A set $T \subseteq \mathbb{T}$ is called a \emph{set of basic types}
    if it is finite and forms a partial meet-semilattice.
\end{defn}

\begin{defn}
    For a set of basic types $T$, its \emph{type closure}
    $\tclos{T} \subseteq (T \, \dot\cup \,\{\, \tot, ), ( \,\})^*$ is defined
    inductively:

    \begin{itemize}
        \item $\sigma \in T \implies \sigma \in \tclos{T}$
        \item $\sigma, \tau \in \tclos{T} \implies (\sigma \tot \tau) \in \tclos{T}$
    \end{itemize}

    Moreover, we can extend $\less$ over
    $\tclos{T}$:
    \begin{itemize}
        \item $(\sigma \tot \sigma') \less (\tau \tot \tau') \iff (\sigma \less \sigma')
            \& (\tau \less \tau')$
    \end{itemize}
\end{defn}

\begin{defn}
    The function $tv : \tclos{\mathbb{T}} \rightarrow 2^\mathbb{T}$, which
    returns the set of type symbols used in a complex type, is defined inductively:

    \begin{itemize}
        \item if $\sigma \in \mathbb{T}$ then $tv(\sigma) = \sigma$
        \item if $\sigma = \sigma' \rightarrow \sigma''$ then
            $tv(\sigma) = tv(\sigma') \cup tv(\sigma'')$
    \end{itemize}
\end{defn}

\begin{prop}
    If $T$ is a set of basic types, then $\tclos{T}$ is a partial meet-semilattice.
\end{prop}

\begin{defn}
    We call a set $X$ \emph{typed in} $T$ $\iff$ there is a function
    \[ typeof : X \rightarrow \tclos{T} \] and $T$ is a partial meet-semilattice.
\end{defn}

\begin{defn}
    If $X, Y$ is a set of basic types and $\varphi: X \rightarrow \tclos{Y}$,
    then $\hat{\varphi} : \tclos{X} \rightarrow \tclos{Y}$ is defined inductively:
    \begin{equation*}
        \hat{\varphi}(\sigma) =
        \begin{cases*}
            \sigma, & $\sigma \in X$ \\
            \hat{\varphi}(\sigma') \rightarrow \hat{\varphi}(\sigma''), &
                $\sigma = \sigma' \rightarrow \sigma'' \in \tclos{X}$ \\
        \end{cases*}
    \end{equation*}
\end{defn}

\subsubsection{Terms}
To define $\lambda$ terms with the types introduced above, a system similar
to Church's $\lambda_\rightarrow$ \cite[chap.~2.4]{ttfp} shall be used. It
extends the original system with constants and constructors.

\begin{defn}
    Let $\mathbb{V}$ be an infinite countable set. We shall call its elements
    \emph{variables}.
\end{defn}

\begin{defn}
    Let $C$ be a countable set, typed in $T$,
    whose elements we call \emph{constants}.

    For a set of basic types $T$, we can define the set of
    \emph{pre-typed $\lambda$-terms} ($\Lambda_T^C$).

    \begin{itemize}
        \item Constant:    \[ c \in C \implies c \in \Lambda_T^C \]
        \item Variable:    \[ v \in \mathbb{V} \implies v \in \Lambda_T^C \]
        \item Application: \[ A, B \in \Lambda_T^C \implies (AB) \in \Lambda_T^C \]
        \item Abstraction: \[ v \in \mathbb{V}, A \in \Lambda_T^C, \sigma \in \tclos{T}
                \implies (\lambda v : \sigma \abstr A) \in \Lambda_T^C \]
        \item Construction: \[ \sigma \in T, A \in \Lambda_T^C
                \implies \sigma[A] \in \Lambda_T^C \]
    \end{itemize}
\end{defn}

\begin{defn}
    Statement, declaration, context, judgement
    \begin{itemize}
        \item For $M \in \Lambda_T^C, \sigma \in \tclos{T}$, $M : \sigma$ is called
            a \emph{statement}. $M$ is called a \emph{subject} and $\sigma$
            is called a \emph{type}.
        \item A statement with a variable as a subject is called a \emph{declaration}.
        \item A set of declarations with different subjects is called a \emph{context}.
        \item A \emph{judgement} has the form $\Gamma \vdash M: \sigma$, where
            $\Gamma$ is a context and $M: \sigma$ is a statement.
    \end{itemize}

    Moreover, appending to contexts is defined as follows:
    \[ \Gamma \circ x : \sigma = \{ y : \tau \in \Gamma \mid y \neq x \}
       \cup \{ x : \sigma \} \]
\end{defn}

\begin{defn}
    To define what it means for a term $M \in \Lambda_T^C$ to have a type,
    we will use derivation rules.
    \begin{itemize}
        \item Constant
            \cenderiv{
                \hypo{c \in C}
                \infer1{\Gamma \vdash c : typeof(c)}
            }
        \item Variable
            \cenderiv{
                \hypo{x : \sigma \in \Gamma}
                \infer1{\Gamma \vdash x : \sigma}
            }
        \item Application
            \cenderiv{
                \hypo{\Gamma \vdash A : \sigma' \tot \sigma''}
                \hypo{\Gamma \vdash B : \tau}
                \hypo{\tau \less \sigma'}
                \infer3{\Gamma \vdash (AB) : \sigma''}
            }
        \item Abstraction
            \cenderiv{
                \hypo{\Gamma \circ x : \tau \vdash A : \sigma}
                \infer1{\Gamma \vdash (\lambda x : \tau \abstr A) : \tau \tot \sigma}
            }
        \item Construction via upcast
            \cenderiv{
                \hypo{\Gamma \vdash A : \sigma}
                \hypo{\sigma \less \tau}
                \infer2{\Gamma \vdash \tau[A] : \tau}
            }
        \item Construction via downcast (dangerous, doesn't need to be included in most cases)
            \cenderiv{
                \hypo{\Gamma \vdash A : \sigma}
                \hypo{\tau \less \sigma}
                \infer2{\Gamma \vdash \tau[A] : \tau}
            }
    \end{itemize}

    Now, $typeof(M)$ for $M \in \Lambda_T^C$ is defined as such:
    \[
        typeof(M) =
        \begin{cases*}
            \sigma & if $\varnothing \vdash M : \sigma$ \\
            \neg ! & otherwise
        \end{cases*}
    \]
    Of course, the above function is nowhere defined for non-closed terms.
\end{defn}

\subsubsection{Type set subsumption}
\begin{defn}
    If $T$ and $S$ are sets of basic types, we say that $T \less S$ if:
    \begin{itemize}
        \item $S \subseteq T$
        \item $\forall \tau \in T \exists \sigma \in S ( \tau \less \sigma )$
    \end{itemize}

    Essentially, this says that $T$ is a specialisation of $S$: any type in
    $T$ is a more concrete variant of some type in $S$.
\end{defn}

If we have $T \less S$, it would be convenient to be able to convert between them.
The conversion from $S$ to $T$ is trivial. The conversion from $T$ to $S$,
however, involves discarding information.

\begin{example}
    For example, let $S = \{ Int, String \}$, supposing the obvious semantics
    behind those names. This is a nice type system - however, one might want to
    be able to encode extra information within types: this comes especially
    handy in the context of CCGs.

    So, we add some extra types: \[ T = \{ Int, String, Distance, Count, NamedEntity \} \]
    We want $\less$ to be defined as \[ Distance \less Int, Count \less Int,
    NamedEntity \less String \]

    Now while doing natural language parsing, we can use $T$. Afterwards
    we no longer need the extra information, so we could discard the extra
    types and return to $S$. To do this, we define a \emph{squash function}.
\end{example}

\begin{defn}
    $\omega: T \rightarrow S$ is a \emph{squash function} for $T \less S$, if:
    \begin{itemize}
        \item $\omega(\tau)$ is a minimal element in $S$
        \item $\tau \less \omega(\tau)$
    \end{itemize}
\end{defn}

\begin{defn}
    If $\omega: T \rightarrow S$ is a squash function for $T \less S$, we can define
    $\omega_{\lambda}: \Lambda_T^C \rightarrow \Lambda_S^C$ inductively:
\end{defn}

From here on $\omega$ will be used freely in place of $\omega_{\lambda}$.

\begin{prop}
    For a squash function $\omega: T \rightarrow S$, $\omega_{\lambda}$ is
    well-defined, namely
    \[ \Gamma \vdash M : \sigma \iff \omega(\Gamma) \vdash \omega(M) : \omega(\sigma) \]
\end{prop}

\subsubsection{Subtype libraries}
\begin{defn}
    A statement in the form $\sigma \lass \tau (\sigma, \tau \in \mathbb{T})$
    is called a \emph{subtype assertion}.
\end{defn}

Since our definition of "subtype" doesn't allow us to subtype a complex type,
we have to work around this by making $\sigma$ be a complex type with the same
syntactic structure as $\tau$ and then subtyping on the level of individual
basic types it is made of. To do this, we need a way to create a new term
with the same syntactic structure of another term - essentially an image which
maps basic types into new basic types.

\begin{defn}
    For $O \subseteq \mathbb{T}, \tau \in \tclos{\mathbb{T} \setminus O}$,
    \[ clone_O(\tau) : tv(\tau) \rightarrow \mathbb{T} \setminus O \]
    is defined inductively:
    \begin{itemize}
        \item if $\tau \in \mathbb{T}$, then for a fresh element
            \footnote{Assume $\mathbb{T}$ is ordered and get the lowest element
            in $\mathbb{T} \setminus O$.}
            $\tau' \in \mathbb{T} \setminus O$, define
            $clone_O(\tau) = \{ (\tau, \tau') \}$
        \item if $\tau = \tau' \tot \tau''$, then:

            Let $clone_O(\tau') = \varphi$, $O' = O \cup range(\varphi)$,
            $clone_{O'}(\tau'') = \psi$.

            Now, define $clone_O(\tau) = \varphi \cup \psi$.
    \end{itemize}
\end{defn}

\begin{defn}
    If we have
    \begin{itemize}
        \item a set of basic types $T$
        \item $\tau \in \tclos{T}$
        \item $\sigma \in \mathbb{T} \setminus T$
        \item a mapping $\varphi: X \rightarrow \tclos{T}$
    \end{itemize}
    Let $\xi = clone_{T \cup \{ \sigma \}}(\tau)$
    We can define \[ T' = T \tadd (\sigma \lass \tau) \text{ and }
                     \varphi' = \varphi \tadd (\sigma \lass \tau) \] as:
    \begin{itemize}
        \item $T' = T \cup range(\xi)$
        \item extend $\less$ for $T'$ with $\sigma' \less \tau'$ for each
            $\xi(\tau') = \sigma'$
        \item $\varphi' = \varphi \cup \{ (\sigma, \hat{\xi}(\tau)) \}$
    \end{itemize}
\end{defn}

\begin{defn}
    A finite sequence of subtype assertions
    $\Theta = \theta_1 ... \theta_n$ is called a \emph{subtype library} over $T$
    if $bt(\Theta) = T \oplus \theta_1 \oplus \theta_2 ... \oplus \theta_n$ is defined.

    Also, we can define the function which gives us all the new type names
    asserted by the subtype library as
    $left(\Theta) = \{ \sigma \mid \sigma \lass \tau \in \Theta \}$

    And we can define the function which maps those new type names to their
    respective types as
    $\varphi = \emptyset \oplus \theta_1 \oplus \theta_2 ... \oplus \theta_n$
\end{defn}

\begin{prop}
    If $T$ is a set of basic types and
    $\Theta = \theta_1 ... \theta_n$ is a subtype library over $T$, it has the
    following properties:
    \begin{itemize}
        \item $\varphi : left(\Theta) \rightarrow \tclos{bt(\Theta)}$
        \item $\sigma \less_{\tclos{T}} \tau \implies \sigma \less_{\tclos{bt(\Theta)}} \tau$
        \item $\sigma \lass \tau \in \Theta \implies \varphi(\sigma) \less \varphi(\tau)$
    \end{itemize}
\end{prop}

\begin{prop}
    If $T$ is a set of basic types and $\Theta$ is a subtype library, then
    $bt(\Theta) \less T$. Even more, there is a unique squash function
    $\omega_{\Theta} : bt(\Theta) \rightarrow T$.
\end{prop}

\end{document}
