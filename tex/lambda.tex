\documentclass[main.tex]{subfiles}
\begin{document}

\subsection{Simply typed $\lambda$-calculus: the sequel}
\label{sec:lambda}

In order to be able to represent the notion of generic and specific concepts,
it is well-suited to use some sort of ordering relation over our types.

One such ordering relation is the \emph{subtype} relation, as presented in
\cite[chap.~15]{pierce}, which will be used here.

\example{
    The subtyping construction is particularly useful for domains like
    geographical queries - it lets us express relations such as the following:
    \begin{align*}
        Capital & < City < Set \\
        Name & < String \\
        Distance & < Number \\
    \end{align*}
}

\subsubsection{Type semilattices}
\begin{defn}
    A \emph{partial meet-semilattice} is a pair $\langle X, \less \rangle$ where:
    \begin{itemize}
        \item $\less$ is a partial-order relation
        \item for any $x, y \in X$, there is at most one $z$ such that
        \[  z \less x, z \less y,
            \forall t \in X (t \less x, t \less y \implies t \less z) \]
        We can define the partial function $\meet : X \times X \leadsto X$ to
        be $x \meet y = z$ for any $x, y, z$ satisfying this condition.
    \end{itemize}
\end{defn}

\begin{defn}
    A partial meet-semilattice $\langle T, \less \rangle$ where
    $T \subseteq \mathbb{T}$ is called a \emph{type semilattice}.

    Whenever the relation is unambiguous, $T$ and $\langle T, \less \rangle$
    will be used interchangeably: we could say "let $T$ be a
    type semilattice", which would refer to $\langle T, \less \rangle$.
\end{defn}

\begin{defn}
    For a type semilattice $T$, we can extend the relation\footnote{
        To make this completely rigorous, $\mathcal{T}$ would have to be defined
        over \emph{lattices}, not their carrier sets, so that the notion of
        "extending the relation" makes sense (because we actually create a
        new relation). These details, however, have been omitted for clarity.
    }
    $\less$ over its type closure:
    \begin{itemize}
        \item $(\sigma \tot \sigma') \less (\tau \tot \tau') \iff (\sigma' \less \sigma)
            \& (\tau \less \tau')$
    \end{itemize}

    \greenbox{
        Note that this definition assumes \emph{contravariant arguments}.
        In essence, the semantics of $f \less g$ is "wherever we can use $g$,
        we can also use $f$". Now, imagine that $f : \alpha' \tot \beta'$,
        $g : \alpha'' \tot \beta''$, and we have a function
        $h : (\alpha'' \tot \beta'') \tot \gamma $ which takes $g$ as
        argument and produces something of type $\gamma$. Supposedly,
        $h$ uses $g$ somewhere in its body and supplies it with something
        of type $\alpha''$.

        Now, we supply $f$ to $h$ instead of $g$ - this $f$ needs to be able
        to take anything of type $\alpha''$ and its subtypes as argument.

        The only way to make this work is to make arguments contravariant,
        while making return values covariant.

        Nevertheless, there exist systems (for example the Dart programming
        language \cite{darttypes}) where covariant arguments are allowed and the
        inconsistencies which
        arise from this decision are left to the user to look out for.
    }
\end{defn}

\begin{prop}
    If $T$ is a type semilattice, then $\tclos{T}$ is a partial meet-semilattice.
\end{prop}
\fixme{need proof}

\subsubsection{Terms}
We will now extend the definition of $\lambda$-term given in \autoref{purelambda:types}
to work with subtypes.

\begin{defn}
    Let $C$ be a countable set, typed in $T$,
    whose elements we call \emph{constants}.

    For a of type semilattice $T$, we can define the set of
    \emph{pre-typed $\lambda$-terms with subtypes} ($\fancylambda{T}{C}$).

    \begin{itemize}
        \item Constant:    \[ c \in C \implies c \in \fancylambda{T}{C} \]
        \item Variable:    \[ v \in \mathbb{V} \implies v \in \fancylambda{T}{C} \]
        \item Application: \[ A, B \in \fancylambda{T}{C} \implies (AB) \in \fancylambda{T}{C} \]
        \item Abstraction: \[ v \in \mathbb{V}, A \in \fancylambda{T}{C}, \sigma \in \tclos{T}
                \implies (\lambda v : \sigma \abstr A) \in \fancylambda{T}{C} \]
        \item Construction: \[ \sigma \in T, A \in \fancylambda{T}{C}
                \implies \sigma[A] \in \fancylambda{T}{C} \]
    \end{itemize}
\end{defn}

\begin{defn}
    Derivation rules for $\lambda$-calculus with subtypes:

    \begin{itemize}
        \item Constant
            \cenderiv{
                \hypo{c \in C}
                \infer1{\Gamma \vdash c : \typeof{c}}
            }
        \item Variable
            \cenderiv{
                \hypo{x : \sigma \in \Gamma}
                \infer1{\Gamma \vdash x : \sigma}
            }
        \item Application
            \cenderiv{
                \hypo{\Gamma \vdash A : \sigma' \tot \sigma''}
                \hypo{\Gamma \vdash B : \tau}
                \hypo{\tau \less \sigma'}
                \infer3{\Gamma \vdash (AB) : \sigma''}
            }
        \item Abstraction
            \cenderiv{
                \hypo{\Gamma \circ x : \tau \vdash A : \sigma}
                \infer1{\Gamma \vdash (\lambda x : \tau \abstr A) : \tau \tot \sigma}
            }
        \item Construction via upcast
            \cenderiv{
                \hypo{\Gamma \vdash A : \sigma}
                \hypo{\sigma \less \tau}
                \infer2{\Gamma \vdash \tau[A] : \tau}
            }
        \item Construction via downcast (dangerous, doesn't need to be included in most cases)
            \cenderiv{
                \hypo{\Gamma \vdash A : \sigma}
                \hypo{\tau \less \sigma}
                \infer2{\Gamma \vdash \tau[A] : \tau}
            }
    \end{itemize}
\end{defn}

\subsubsection{Type set subsumption}
\begin{defn}
    If $T$ and $S$ are type semilattices, we say that $T \less S$ if:
    \begin{itemize}
        \item $S \subseteq T$
        \item $\forall \tau \in T \exists \sigma \in S ( \tau \less \sigma )$
    \end{itemize}

    Essentially, this says that $T$ is a specialisation of $S$: any type in
    $T$ is a more concrete variant of some type in $S$.
\end{defn}

If we have $T \less S$, it would be convenient to be able to convert between them.
The conversion from $S$ to $T$ is trivial. The conversion from $T$ to $S$,
however, involves discarding information.

\example{
    For example, let $S = \{ Int, String \}$, supposing the obvious semantics
    behind those names. This is a nice type system - however, one might want to
    be able to encode extra information within types: this comes especially
    handy in the context of CCGs.

    So, we add some extra types: \[ T = \{ Int, String, Distance, Count, NamedEntity \} \]
    We want $\less$ to be defined as \[ Distance \less Int, Count \less Int,
    NamedEntity \less String \]

    Now while doing natural language parsing, we can use $T$. Afterwards
    we no longer need the extra information, so we could discard the extra
    types and return to $S$. To do this, we define a \emph{squash function}.
}

\begin{defn}
    $\omega: T \rightarrow S$ is a \emph{squash function} for $T \less S$, if
    for each $\tau$, $\omega(\tau)$ is a minimal element in $S$ such that
    $\tau \less \omega(\tau)$.
\end{defn}

\begin{defn}
    If $\omega: T \rightarrow S$ is a squash function for $T \less S$, we can define
    $\omega_{\lambda}: \fancylambda{T}{C} \rightarrow \fancylambda{S}{C}$ inductively:
    \fixme{fill this}
\end{defn}

From here on $\omega$ will be used freely in place of $\omega_{\lambda}$.

\begin{prop}
    For a squash function $\omega: T \rightarrow S$, $\omega_{\lambda}$ is
    well-defined, namely
    \[ \Gamma \vdash M : \sigma \iff \omega(\Gamma) \vdash \omega(M) : \omega(\sigma) \]
\end{prop}
\fixme{need proof}

\subsubsection{Subtype libraries}
\begin{defn}
    A statement in the form $\sigma \lass \tau (\sigma, \tau \in \mathbb{T})$
    is called a \emph{subtype assertion}.
\end{defn}

Since our definition of "subtype" doesn't allow us to subtype a complex type,
we have to work around this by making $\sigma$ be a complex type with the same
syntactic structure as $\tau$ and then subtyping on the level of individual
basic types it is made of. To do this, we need to be able to create a new term
with the same syntactic structure of another term.

\example{
    Suppose we have the basic types $Int$ and $String$, and we want to extend
    them.

    For example, take the subtype assertion $F \lass ( Int \tot String )$.
    Let $\tau = ( Int \tot String )$. We want $F$ to correspond to a type
    $\sigma$ such that $\sigma \less \tau$. To do this, we clone
    the complex type $\tau$, creating a new type with the same
    syntactic structure: $\sigma = ( Int' \tot String' )$

    Now we extend our subtyping relation to include $ Int \less Int', String' \less String $,
    which indeed gives that $\sigma \less \tau$.

    Again, take note of the argument contravariance.

    To remember that $F$ stands for $\sigma$, we will iteratively build a
    function $\varphi$ such that $\varphi(F) = \sigma$.
}

The following few definitions will formalise this process.

First, having a type $\tau$, we need to be able to create a new type
that is its clone
(has the same syntactic structure), and is a subtype of $\tau$.

To deal with contravariance, we will differentiate between a "subtype clone"
($\subtyper{clone}$),
which clones a type into a new one which will be its subtype, and a
"supertype clone", ($\suptyper{clone}$)
which does the opposite - this way we will be able to
use the $\suptyper{clone}$ in arguments and $\subtyper{clone}$ in return
values.

To do this, we will use the mappings $\subtyper{\xi}$ and $\suptyper{\xi}$
which rename the basic types used in $\tau$ into new type symbols. To clone
$\tau$, we will recursively replace argument types and return value types
with their respective clones. One way to deal with contravariance is

\newcommand\clonesub{\subtyper{clone}_{\subtyper{\xi} \suptyper{\xi}}}
\newcommand\clonesup{\suptyper{clone}_{\subtyper{\xi} \suptyper{\xi}}}

\begin{defn}
    Let $\langle T, \less \rangle$ be a type semilattice, $\tau \in \tclos{T}$
    be a type and $\subtyper{\xi}, \suptyper{\xi}$ be mappings from a
    superset of
    $ts(\tau)$ into $\mathbb{T}$ such that
    $range(\suptyper{\xi}) \cap range(\subtyper{\xi}) = \varnothing$.

    $\suptyper{clone}_{\subtyper{\xi} \suptyper{\xi}}$ and
    $\subtyper{clone}_{\subtyper{\xi} \suptyper{\xi}}$ are defined by
    mutial recursion:

    \[
        \subtyper{clone}_{\subtyper{\xi} \suptyper{\xi}}(\tau) =
        \begin{cases*}
            \subtyper{\xi}(\tau), &
                $\tau \in T$ \\
            \suptyper{clone}_{\subtyper{\xi} \suptyper{\xi}}(\tau_1)
                \tot \subtyper{clone}_{\subtyper{\xi} \suptyper{\xi}}(\tau_2), &
                $\tau = \tau_1 \tot \tau_2$ \\
        \end{cases*}
    \]

    \[
        \suptyper{clone}_{\subtyper{\xi} \suptyper{\xi}}(\tau) =
        \begin{cases*}
            \suptyper{\xi}(\tau), &
                $\tau \in T$ \\
            \subtyper{clone}_{\subtyper{\xi} \suptyper{\xi}}(\tau_1)
                \tot \suptyper{clone}_{\subtyper{\xi} \suptyper{\xi}}(\tau_2), &
                $\tau = \tau_1 \tot \tau_2$ \\
        \end{cases*}
    \]

\end{defn}

\begin{defn}
    \label{def:subadd}
    Suppose we have
    \begin{itemize}
        \item a type semilattice $\langle T, \less \rangle$
        \item a type $\tau \in \tclos{T}$
        \item a type symbol$\sigma \in \mathbb{T} \setminus T$
        \item a mapping $\varphi$ with $range(\varphi) = \tclos{T}$
    \end{itemize}
    Let $\suptyper{\xi}$ and $\subtyper{\xi}$ be injections from
    $ts(\tau)$ into $\mathbb{T} \setminus (T \cup \{ \sigma \})$ such that
    $range(\suptyper{\xi}) \cap range(\subtyper{\xi}) = \varnothing$\footnote{
        $\suptyper{\xi}$ and $\subtyper{\xi}$ depend on $\tau$, $T$ and
        $\sigma$. If one wants to make their choice constrictive, they may,
        for example, assume that $\mathbb{T}$ is ordered, take the minimal
        elements that aren't in $T \cup \{ \sigma \}$ and map to them in
        order.
    }.

    Now define the operation $\tadd$ as:
        \[ \langle \langle T, \less \rangle, \varphi \rangle
            \tadd (\sigma \lass \tau)
            \defeq
            \langle \langle T', \less' \rangle, \varphi' \rangle
        \] where:
    \begin{itemize}
        \item $\rho = \clonesub(\tau)$
        \item $T' = T \cup ((range(\subtyper{\xi}) \cup range(\suptyper{\xi})) \cap ts(\rho))$
        \item $\less'$ is the transitive and reflexive closure of
            $\less \cup \{ (\sigma', \tau') \in T' \times T' \mid \subtyper{\xi}(\tau') = \sigma' \}
                   \cup \{ (\sigma', \tau') \in T' \times T' \mid \suptyper{\xi}(\sigma') = \tau' \}$
        \item $\varphi' = \varphi \cup \{ \rho \}$
    \end{itemize}
\end{defn}

\begin{defn}
    A finite sequence of subtype assertions
    $\Theta_T = \theta_1 ... \theta_n$ is called a \emph{subtype library} over $T$
    if $\hat{\Theta}_T = \langle \langle T, \less \rangle, \emptyset \rangle \oplus \theta_1 \oplus \theta_2 ... \oplus \theta_n$
    is defined\footnote{
        When trying to redefine a previously defined type, the sequence is not
        a subtype library because of the restriction for $\sigma$
        in definition \ref{def:subadd}.
    }.

    Also, we can define the function which gives us all the new type names
    asserted by the subtype library as
    $left(\Theta_T) = \{ \sigma \mid \sigma \lass \tau \in \Theta \}$
\end{defn}

\begin{prop}
    If $T$ is a type semilattice and
    $\Theta_T = \theta_1 ... \theta_n$ is a subtype library over $T$, where
    $\hat{\Theta}_T = \langle \langle T', \less' \rangle, \varphi \rangle$
    the following properties hold:
    \begin{itemize}
        \item $\varphi : left(\Theta) \rightarrow \tclos{T'}$
        \item $\sigma \less \tau \implies \sigma \less' \tau$
        \item $\sigma \lass \tau \in \Theta \implies \varphi(\sigma) \less \hat{\varphi}(\tau)$
    \end{itemize}
\end{prop}
\fixme{need proof}

\begin{prop}
    If $T$ is a type semilattice and
    $\Theta_T = \theta_1 ... \theta_n$ is a subtype library over $T$, where
    $\hat{\Theta}_T = \langle \langle T', \less' \rangle, \varphi \rangle$,
    then $T' \less T$. Even more, there is a unique squash function
    $\omega_{\Theta} : T' \rightarrow T$.
\end{prop}
\fixme{need proof!}
\end{document}
