\documentclass[main.tex]{subfiles}
\begin{document}

\subsection{Simply typed $\lambda$-calculus: the sequel}
\label{sec:lambda}

In order to be able to represent the notion of generic and specific concepts,
it is well-suited to use some sort of ordering relation over our types.

One such ordering relation is the \emph{subtype} relation, as presented in
\cite[chap.~15]{pierce}, which will be used here.

\example{
    The subtyping construction is particularly useful for domains like
    geographical queries - it lets us express relations such as the following:
    \begin{align*}
        Capital & < City < Set \\
        Name & < String \\
        Distance & < Number \\
    \end{align*}
}

\subsubsection{Type semilattices}
\begin{defn}
    A \emph{partial meet-semilattice} is a pair $\langle X, \less \rangle$ where:
    \begin{itemize}
        \item $\less$ is a partial-order relation
        \item for any $x, y \in X$, there is at most one $z$ such that
        \[  z \less x, z \less y,
            \forall t \in X (t \less x, t \less y \implies t \less z) \]
        We can define the partial function $\meet : X \times X \leadsto X$ to
        be $x \meet y = z$ for any $x, y, z$ satisfying this condition.
    \end{itemize}
\end{defn}

\begin{defn}
    A partial meet-semilattice $\langle T, \less \rangle$ where
    $T \subseteq \mathbb{T}$ is called a \emph{type semilattice}.

    Whenever the relation is unambiguous, $T$ and $\langle T, \less \rangle$
    will be used interchangeably: we could say "let $T$ be a
    type semilattice", which would refer to $\langle T, \less \rangle$.
\end{defn}

\begin{defn}
    For a type semilattice $T$, we can extend the relation\footnote{
        To make this completely rigorous, $\mathcal{T}$ would have to be defined
        over \emph{lattices}, not their carrier sets, so that the notion of
        "extending the relation" makes sense (because we actually create a
        new relation). These details, however, have been omitted for clarity.
    }
    $\less$ over its type closure:
    \begin{itemize}
        \item $(\sigma \tot \sigma') \less (\tau \tot \tau') \iff (\sigma' \less \sigma)
            \& (\tau \less \tau')$
    \end{itemize}

    \greenbox{
        Note that this definition assumes \emph{contravariant arguments}.
        In essence, the semantics of $f \less g$ is "wherever we can use $g$,
        we can also use $f$". Now, imagine that $f : \alpha' \tot \beta'$,
        $g : \alpha'' \tot \beta''$, and we have a function
        $h : (\alpha'' \tot \beta'') \tot \gamma $ which takes $g$ as
        argument and produces something of type $\gamma$. Supposedly,
        $h$ uses $g$ somewhere in its body and supplies it with something
        of type $\alpha''$.

        Now, we supply $f$ to $h$ instead of $g$ - this $f$ needs to be able
        to take anything of type $\alpha''$ and its subtypes as argument.

        The only way to make this work is to make arguments contravariant,
        while making return values covariant.
    }
\end{defn}

\begin{prop}
    If $T$ is a type semilattice, then $\tclos{T}$ is a partial meet-semilattice.
\end{prop}

\subsubsection{Terms}
We will now extend the definition of $\lambda$-term given in \autoref{purelambda:types}
to work with subtypes.

\begin{defn}
    Let $C$ be a countable set, typed in $T$,
    whose elements we call \emph{constants}.

    For a of type semilattice $T$, we can define the set of
    \emph{pre-typed $\lambda$-terms} ($\Lambda_T^C$).

    \begin{itemize}
        \item Constant:    \[ c \in C \implies c \in \Lambda_T^C \]
        \item Variable:    \[ v \in \mathbb{V} \implies v \in \Lambda_T^C \]
        \item Application: \[ A, B \in \Lambda_T^C \implies (AB) \in \Lambda_T^C \]
        \item Abstraction: \[ v \in \mathbb{V}, A \in \Lambda_T^C, \sigma \in \tclos{T}
                \implies (\lambda v : \sigma \abstr A) \in \Lambda_T^C \]
        \item Construction: \[ \sigma \in T, A \in \Lambda_T^C
                \implies \sigma[A] \in \Lambda_T^C \]
    \end{itemize}
\end{defn}

\begin{defn}
    Derivation rules for $\lambda$-calculus with subtypes:

    \begin{itemize}
        \item Constant
            \cenderiv{
                \hypo{c \in C}
                \infer1{\Gamma \vdash c : typeof(c)}
            }
        \item Variable
            \cenderiv{
                \hypo{x : \sigma \in \Gamma}
                \infer1{\Gamma \vdash x : \sigma}
            }
        \item Application
            \cenderiv{
                \hypo{\Gamma \vdash A : \sigma' \tot \sigma''}
                \hypo{\Gamma \vdash B : \tau}
                \hypo{\tau \less \sigma'}
                \infer3{\Gamma \vdash (AB) : \sigma''}
            }
        \item Abstraction
            \cenderiv{
                \hypo{\Gamma \circ x : \tau \vdash A : \sigma}
                \infer1{\Gamma \vdash (\lambda x : \tau \abstr A) : \tau \tot \sigma}
            }
        \item Construction via upcast
            \cenderiv{
                \hypo{\Gamma \vdash A : \sigma}
                \hypo{\sigma \less \tau}
                \infer2{\Gamma \vdash \tau[A] : \tau}
            }
        \item Construction via downcast (dangerous, doesn't need to be included in most cases)
            \cenderiv{
                \hypo{\Gamma \vdash A : \sigma}
                \hypo{\tau \less \sigma}
                \infer2{\Gamma \vdash \tau[A] : \tau}
            }
    \end{itemize}
\end{defn}

\subsubsection{Type set subsumption}
\begin{defn}
    If $T$ and $S$ are type semilattices, we say that $T \less S$ if:
    \begin{itemize}
        \item $S \subseteq T$
        \item $\forall \tau \in T \exists \sigma \in S ( \tau \less \sigma )$
    \end{itemize}

    Essentially, this says that $T$ is a specialisation of $S$: any type in
    $T$ is a more concrete variant of some type in $S$.
\end{defn}

If we have $T \less S$, it would be convenient to be able to convert between them.
The conversion from $S$ to $T$ is trivial. The conversion from $T$ to $S$,
however, involves discarding information.

\example{
    For example, let $S = \{ Int, String \}$, supposing the obvious semantics
    behind those names. This is a nice type system - however, one might want to
    be able to encode extra information within types: this comes especially
    handy in the context of CCGs.

    So, we add some extra types: \[ T = \{ Int, String, Distance, Count, NamedEntity \} \]
    We want $\less$ to be defined as \[ Distance \less Int, Count \less Int,
    NamedEntity \less String \]

    Now while doing natural language parsing, we can use $T$. Afterwards
    we no longer need the extra information, so we could discard the extra
    types and return to $S$. To do this, we define a \emph{squash function}.
}

\begin{defn}
    $\omega: T \rightarrow S$ is a \emph{squash function} for $T \less S$, if:
    \begin{itemize}
        \item $\omega(\tau)$ is a minimal element in $S$
        \item $\tau \less \omega(\tau)$
    \end{itemize}
\end{defn}

\begin{defn}
    If $\omega: T \rightarrow S$ is a squash function for $T \less S$, we can define
    $\omega_{\lambda}: \Lambda_T^C \rightarrow \Lambda_S^C$ inductively:
\end{defn}

From here on $\omega$ will be used freely in place of $\omega_{\lambda}$.

\begin{prop}
    For a squash function $\omega: T \rightarrow S$, $\omega_{\lambda}$ is
    well-defined, namely
    \[ \Gamma \vdash M : \sigma \iff \omega(\Gamma) \vdash \omega(M) : \omega(\sigma) \]
\end{prop}

\subsubsection{Subtype libraries}
\begin{defn}
    A statement in the form $\sigma \lass \tau (\sigma, \tau \in \mathbb{T})$
    is called a \emph{subtype assertion}.
\end{defn}

Since our definition of "subtype" doesn't allow us to subtype a complex type,
we have to work around this by making $\sigma$ be a complex type with the same
syntactic structure as $\tau$ and then subtyping on the level of individual
basic types it is made of. To do this, we need a way to create a new term
with the same syntactic structure of another term - essentially an image which
maps basic types into new basic types.

\example{
    Suppose we have the basic types $Int$ and $String$, and we want to extend
    them.

    For example, take the subtype assertion $F \lass ( Int \tot String )$.
    Let $\tau = ( Int \tot String )$. We want $F$ to correspond to a type
    $\sigma$ such that $\sigma \less \tau$. To do this, we clone
    the complex type $\tau$, creating a new type with the same
    syntactic structure: $\sigma = ( Int' \tot String' )$

    Now we extend our subtyping relation to include $ Int' \less Int, String' \less String $,
    which indeed gives that $\sigma \less \tau$.

    To remember that $F$ stands for $\sigma$, we will iteratively build a
    function $\varphi$ such that $\varphi(F) = \sigma$.

    The next few definitions will formalise this process.
}

\begin{defn}
    For $O \subseteq \mathbb{T}, \tau \in \tclos{\mathbb{T} \setminus O}$,
    the following function constructs a \emph{mapping} which returns a new (not
    in $O$) symbol for each basic type found in $\tau$.

    \[ clone_O(\tau) : ts(\tau) \rightarrow \mathbb{T} \setminus O \]
    is defined inductively:
    \begin{itemize}
        \item if $\tau \in \mathbb{T}$, then for a fresh element\footnote{
            For example, assume $\mathbb{T}$ is ordered and get the lowest element
            in $\mathbb{T} \setminus O$ to make this choice unique.}
            $\tau' \in \mathbb{T} \setminus O$, define
            $clone_O(\tau) = \{ (\tau, \tau') \}$
        \item if $\tau = \tau' \tot \tau''$, then:

            Let $clone_O(\tau') = \varphi$, $O' = O \cup range(\varphi)$,
            $clone_{O'}(\tau'') = \psi$.

            Now, define $clone_O(\tau) = \varphi \cup \psi$.
    \end{itemize}
\end{defn}

\example{
    In light of our example, $clone_O( Int \tot String ) =
    \xi: ts(\tau) \rightarrow \mathbb{T} \setminus O$ such that
    \[ \xi(\sigma) = \begin{cases*}
            Int', & $\sigma = Int$ \\
            String', & $\sigma = String $
        \end{cases*} \]
}

\begin{defn}
    \label{def:subadd}
    If we have
    \begin{itemize}
        \item a type semilattice $\langle T, \less \rangle$
        \item $\tau \in \tclos{T}$
        \item $\sigma \in \mathbb{T} \setminus T$
        \item a mapping $\varphi$ with $range(\varphi) = \tclos{T}$
    \end{itemize}
    Let $\xi = clone_{T \cup \{ \sigma \}}(\tau)$.
    Now we will define \[ \langle \langle T', \less' \rangle, \varphi' \rangle
        = \langle \langle T, \less \rangle, \varphi \rangle
        \tadd (\sigma \lass \tau) \] as:
    \begin{itemize}
        \item $T' = T \cup range(\xi)$
        \item $\less'$ is the transitive and reflexive closure of
            $\less \cup \{ (\sigma', \tau') \mid \xi(\tau') = \sigma' \}$
        \item $\varphi' = \varphi \cup \{ (\sigma, \hat{\xi}(\tau)) \}$
    \end{itemize}
\end{defn}

\begin{defn}
    A finite sequence of subtype assertions
    $\Theta_T = \theta_1 ... \theta_n$ is called a \emph{subtype library} over $T$
    if $\hat{\Theta}_T = \langle \langle T, \less \rangle, \emptyset \rangle \oplus \theta_1 \oplus \theta_2 ... \oplus \theta_n$
    is defined\footnote{
        When trying to redefine a previously defined type, the sequence is not
        a subtype library because of the restriction for $\sigma$
        in definition \ref{def:subadd}.
    }.

    Also, we can define the function which gives us all the new type names
    asserted by the subtype library as
    $left(\Theta_T) = \{ \sigma \mid \sigma \lass \tau \in \Theta \}$
\end{defn}

\begin{prop}
    If $T$ is a type semilattice and
    $\Theta_T = \theta_1 ... \theta_n$ is a subtype library over $T$, where
    $\hat{\Theta}_T = \langle \langle T', \less' \rangle, \varphi \rangle$
    the following properties hold:
    \begin{itemize}
        \item $\varphi : left(\Theta) \rightarrow \tclos{T'}$
        \item $\sigma \less \tau \implies \sigma \less' \tau$
        \item $\sigma \lass \tau \in \Theta \implies \varphi(\sigma) \less \hat{\varphi}(\tau)$
    \end{itemize}
\end{prop}

\begin{prop}
    If $T$ is a type semilattice and
    $\Theta_T = \theta_1 ... \theta_n$ is a subtype library over $T$, where
    $\hat{\Theta}_T = \langle \langle T', \less' \rangle, \varphi \rangle$,
    then $T' \less T$. Even more, there is a unique squash function
    $\omega_{\Theta} : T' \rightarrow T$.
\end{prop}

\subsubsection{Type-based term rewriting}

\[
rewrite(R, \Gamma, A, \tau) =
\begin{cases*}
    \langle A'', \Gamma' \rangle,
    & \parbox{.6\textwidth}{\vspace{1em}
        $R(A', \tau) = A''$ \\
        $\langle A', \Gamma' \rangle = coerce(R, \Gamma, A, \tau)$ \\
        \vspace{1em}} \\
\end{cases*}
\]

\[
coerce(R, \Gamma, A, \tau) =
\begin{cases*}
    \langle x, \{ x : (\tau \unify \sigma) \} \rangle,
    & \parbox{.6\textwidth}{\vspace{1em}
        $(x : \sigma) \in \Gamma, A = x$
        \vspace{1em}} \\
    \langle M'N', \Gamma' \unify \Gamma'' \rangle,
    & \parbox{.6\textwidth}{\vspace{1em}
        $\langle M', \Gamma' \rangle = rewrite(R, \Gamma, N, \sigma \unify \sigma')$ \\
        $\langle N', \Gamma'' \rangle = rewrite(R, \Gamma, M, (\sigma \unify \sigma') \tot (\tau \unify \tau'))$ \\
        $\Gamma \vdash N : \sigma$ \\
        $\Gamma \vdash M : \sigma' \tot \tau', A = MN$\\
        \vspace{1em}} \\
    \langle \lambda x : (\sigma' \unify \sigma'') \abstr M', \Gamma' \setminus x \rangle,
    & \parbox{.6\textwidth}{\vspace{1em}
        $(x : \sigma'') \in \Gamma'$ \\
        $\Gamma' = rewrite(R, \Gamma \circ x : \sigma, M, \nu \unify \nu')$ \\
        $\tau = \sigma' \tot \nu'$ \\
        $(\Gamma \circ x : \sigma) \vdash M : \nu, A = \lambda x : \sigma \abstr M$ \\
        \vspace{1em}} \\
    \langle c, \{ \} \rangle,
    & \parbox{.6\textwidth}{\vspace{1em}
        $A = c \in C$ \\
        \vspace{1em}} \\
    \langle \sigma[M'], \Gamma' \rangle,
    & \parbox{.6\textwidth}{\vspace{1em}
        $\langle M', \Gamma' \rangle = rewrite(R, \Gamma, M, \sigma)$ \\
        $A = \sigma[M]$ \\
        \vspace{1em}} \\
\end{cases*}
\]

\end{document}
