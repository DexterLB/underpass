\documentclass[main.tex]{subfiles}
\begin{document}

\subsection{Simply typed $\lambda$-calculus}
\label{sec:lambda}

For representing compositional terms, a version of simply typed lambda calculus
will be used.

\subsubsection{Types}
\begin{defn}
    If the partial-order relation $\less \subseteq X \times X$ exists,
    we can define the operator $\meet : X \times X \rightarrow X$ as the
    maximum element lower than both arguments, namely:
    \[ x \meet y = z \iff z \less x, z \less y,
        \forall t \in X (t \less x, t \less y \implies t \less z) \]
\end{defn}

\begin{defn}
    A set $T$ is called a \emph{set of types} whenever all of the following
    are true:
    \begin{itemize}
        \item $T$ is finite
        \item There exists a partial order relation $\less \subseteq T \times T$
        \item If $x \meet y = z'$ and $x \meet y = z''$, then $z' = z''$
    \end{itemize}
\end{defn}

\begin{defn}
    For a set $T$, its \emph{type closure} $\mathcal{T}(T)$ is defined
    inductively:

    \begin{itemize}
        \item $\sigma \in T \implies \sigma \in \mathcal{T}(T)$
        \item $\sigma, \tau \in \mathcal{T}(T) \implies (\sigma \tot \tau) \in \mathcal{T}(T)$
    \end{itemize}

    Moreover, we can define a relation $\lesss$ which extends $\less$ over
    $\mathcal{T}(T)$:
    \begin{itemize}
        \item $\sigma, \tau \in T \implies \sigma \lesss \tau = \sigma \less \tau$
        \item $(\sigma \tot \sigma'), (\tau \tot \tau') \in \mathcal{T}(T) \implies
            (\sigma \tot \sigma') \lesss (\tau \tot \tau') = (\sigma \less \sigma')
            \& (\tau \less \tau')$
    \end{itemize}
\end{defn}

\begin{prop}
    If $T$ is a set of types, then $\mathcal{T}(T)$ is a set of types.
\end{prop}

\begin{defn}
    We call a set $X$ \emph{typed in} $T$ $\iff$ there is a function
    \[ typeof : X \rightarrow T \] and $T$ is a type closure.
\end{defn}

\subsubsection{Terms}
To define $\lambda$ terms with the types introduced above, a system similar
to Church's $\lambda_\rightarrow$ \cite[chap.~2.4]{ttfp} shall be used. It
extends the original system with constants and constructors.

\begin{defn}
    Let $\mathbb{V}$ be an infinite countable set. We shall call its elements
    \emph{variables}.
\end{defn}

\begin{defn}
    Let $C$ be a countable set, typed in $T$,
    whose elements we call \emph{constants}.

    For a type semilattice $T$, we can define the set of
    \emph{pre-typed $\lambda$-terms} ($\Lambda_T^C$).

    \begin{itemize}
        \item Constant:    \[ c \in C \implies c \in \Lambda_T^C \]
        \item Variable:    \[ v \in \mathbb{V} \implies v \in \Lambda_T^C \]
        \item Application: \[ A, B \in \Lambda_T^C \implies (AB) \in \Lambda_T^C \]
        \item Abstraction: \[ v \in \mathbb{V}, A \in \Lambda_T^C, \sigma \in T
                \implies (\lambda v : \sigma \abstr A) \in \Lambda_T^C \]
        \item Construction: \[ \sigma \in T, A \in \Lambda_T^C
                \implies \sigma[A] \in \Lambda_T^C \]
    \end{itemize}
\end{defn}

\begin{defn}
    Statement, declaration, context, judgement
    \begin{itemize}
        \item For $M \in \Lambda_T^C, \sigma \in T$, $M : \sigma$ is called
            a \emph{statement}. $M$ is called a \emph{subject} and $\sigma$
            is called a \emph{type}.
        \item A statement with a variable as a subject is called a \emph{declaration}.
        \item A set of declarations with different subjects is called a \emph{context}.
        \item A \emph{judgement} has the form $\Gamma \vdash M: \sigma$, where
            $\Gamma$ is a context and $M: \sigma$ is a statement.
    \end{itemize}

    Moreover, appending to contexts is defined as follows:
    \[ \Gamma \circ x : \sigma = \{ y : \tau \in \Gamma \mid y \neq x \}
       \cup \{ x : \sigma \} \]
\end{defn}

\begin{defn}
    To define what it means for a term $M \in \Lambda_T^C$ to have a type,
    we will use derivation rules.
    \begin{itemize}
        \item Constant
            \cenderiv{
                \hypo{c \in C}
                \infer1{\Gamma \vdash x : typeof(c)}
            }
        \item Variable
            \cenderiv{
                \hypo{x : \sigma \in \Gamma}
                \infer1{\Gamma \vdash x : \sigma}
            }
        \item Application
            \cenderiv{
                \hypo{\Gamma \vdash A : \sigma' \tot \sigma''}
                \hypo{\Gamma \vdash B : \tau}
                \hypo{!(\tau \meet \sigma')}
                \infer3{\Gamma \vdash (AB) : \sigma''}
            }
        \item Abstraction
            \cenderiv{
                \hypo{\Gamma \circ x : \tau \vdash A : \sigma}
                \infer1{\Gamma \vdash (\lambda x : \tau \abstr A) : \tau \tot \sigma}
            }
        \item Construction via downcast
            \cenderiv{
                \hypo{\Gamma \vdash A : \sigma}
                \hypo{\tau \less \sigma}
                \infer2{\Gamma \vdash \tau[A] : \tau}
            }
        \item Construction via upcast (dangerous, doesn't need to be included in most cases)
            \cenderiv{
                \hypo{\Gamma \vdash A : \sigma}
                \hypo{\sigma \less \tau}
                \infer2{\Gamma \vdash \tau[A] : \tau}
            }
    \end{itemize}

    Now, $typeof(M)$ for $M \in \Lambda_T^C$ is defined as such:
    \[
        typeof(M) =
        \begin{cases*}
            \sigma & if $\varnothing \vdash M : \sigma$ \\
            \neg ! & otherwise
        \end{cases*}
    \]
    Of course, the above function is nowhere defined for non-closed terms.
\end{defn}

\begin{defn}
    A term is \emph{subtype-sound}, if for every subterm $M$
    ($\Gamma \vdash M : \sigma$) and local context
    $\Gamma_M$ the following applies:
        \[ \text{if } M = (AB), \Gamma_M \vdash A : \sigma' \tot \sigma'',
            \Gamma_M \vdash B : \tau,
            !(\sigma' \meet \tau) \text{, then }
            \tau \less \sigma' \]
\end{defn}

\subsubsection{Subtype libraries}
\begin{defn}
    Let $\mathbb{T}$ be an infinitely countable set of items we call
    \emph{type variables}.

    Let $T$ be a set of types.

    A statement in the form $\sigma \lass \tau$, where
    $\sigma \in \mathbb{T}, \tau \in \mathcal{T}(T \cup \mathbb{T})$,
    $\sigma \not\in \tau$,
    is called a \emph{subtype assertion}.

    A set of subtype assertions $\Theta$ is called a \emph{subtype library}.
\end{defn}

\begin{defn}
    Subtypes according to a subtype library
    \begin{itemize}
        \item $\sigma \lass \tau \in \Theta
            \implies \Theta \vdash \sigma \lesss \tau$
        \item $\Theta \vdash \sigma \lesss (\tau' \tot \tau'')
            \implies \Theta \vdash \sigma_{\tau'} \lesss \tau',
            \Theta \vdash \sigma_{\tau''} \lesss \tau''$
    \end{itemize}
\end{defn}

\begin{defn}
    A subtype library can induce a set of basic types and its respective
    subtype relation:
    \begin{itemize}
        \item $basic(\Theta) = \{ \sigma \mid
            \Theta \vdash \sigma \lesss \pi, \sigma \neq (\tau' \tot \tau'') \} $
        \item For $\sigma, \tau \in basic(\Theta),
            \sigma \less \tau \iff \Theta \vdash \sigma \lesss \tau$
    \end{itemize}
\end{defn}

\begin{prop}
    For $\sigma, \tau \in \mathcal{T}(basic(\Theta))$,
    \[ \sigma \lesss \tau \iff \Theta \vdash \sigma \lesss \tau \]
\end{prop}

\begin{prop}
    $\mathcal{T}(basic(\Theta))$ is a set of types
\end{prop}
\end{document}
