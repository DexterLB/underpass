\documentclass[main.tex]{subfiles}
\begin{document}

\subsection{Simply typed $\lambda$-calculus: the sequel}
\label{sec:lambda}

In order to be able to represent the notion of generic and specific concepts,
it is well-suited to use some sort of ordering relation over our types.

One such ordering relation is the \emph{subtype} relation, as presented in
\cite[chap.~15]{pierce}, which will be used here.

\example{
    The subtyping construction is particularly useful for domains like
    geographical queries - it lets us express relations such as the following:
    \begin{align*}
        Capital & \less City \less Set \\
        Name & \less String \\
        Distance & \less Number \\
    \end{align*}
}

\subsubsection{Type semilattices}
\fixme{This section is fundamentally flawed (contravariance doesn't preserve
    semilattices, so we need \emph{lattices}). Rework it to talk about lattices
    or ditch it altogether.}
\begin{defn}
    A \emph{partial meet-semilattice} is a pair $\langle X, \less \rangle$ where:
    \begin{itemize}
        \item $\less$ is a partial-order relation
        \item for any $x, y \in X$, there is at most one $z$ such that
        \[  z \less x, z \less y,
            \forall t \in X (t \less x, t \less y \implies t \less z) \]
        We can define the partial function $\meet : X \times X \leadsto X$ to
        be $x \meet y = z$ for any $x, y, z$ satisfying this condition.
    \end{itemize}
\end{defn}

\begin{defn}
    A partial meet-semilattice $\langle T, \less \rangle$ where
    $T \subseteq \tsymbs$ is called a \emph{type semilattice}.

    Whenever the relation is unambiguous, $T$ and $\langle T, \less \rangle$
    will be used interchangeably: we could say "let $T$ be a
    type semilattice", which would refer to $\langle T, \less \rangle$.
\end{defn}

\begin{defn}
    For a type semilattice $T$, we can extend the relation\footnote{
        To make this completely rigorous, $\mathcal{T}$ would have to be defined
        over \emph{lattices}, not their carrier sets, so that the notion of
        "extending the relation" makes sense (because we actually create a
        new relation). These details, however, have been omitted for clarity.
    }
    $\less$ over its type closure:
    \begin{itemize}
        \item $(\sigma \tot \sigma') \less (\tau \tot \tau') \iff (\sigma' \less \sigma)
            \& (\tau \less \tau')$
    \end{itemize}

    \greenbox{
        Note that this definition assumes \emph{contravariant arguments}.
        In essence, the semantics of $f \less g$ is "wherever we can use $g$,
        we can also use $f$". Now, imagine that $f : \alpha' \tot \beta'$,
        $g : \alpha'' \tot \beta''$, and we have a function
        $h : (\alpha'' \tot \beta'') \tot \gamma $ which takes $g$ as
        argument and produces something of type $\gamma$. Supposedly,
        $h$ uses $g$ somewhere in its body and supplies it with something
        of type $\alpha''$.

        Now, we supply $f$ to $h$ instead of $g$ - this $f$ needs to be able
        to take anything of type $\alpha''$ and its subtypes as argument.

        The only way to make this work is to make arguments contravariant,
        while making return values covariant.

        Nevertheless, there exist systems (for example the Dart programming
        language \cite{darttypes}) where covariant arguments are allowed and the
        inconsistencies which
        arise from this decision are left to the user to look out for.
    }
\end{defn}

\begin{prop}
    If $T$ is a type semilattice, then $\tclos{T}$ is a partial meet-semilattice.
\end{prop}
\fixme{need proof}

\subsubsection{Terms}
We will now extend the definition of $\lambda$-term given in \cref{purelambda:types}
to work with subtypes.

For a of type semilattice $T$, we can define the set of
\emph{pre-typed $\lambda$-terms with subtypes} ($\fancylambda{T}{C}$).

\begin{defn}
    Let $C \subset \const$ be a set of constants, typed in $T$.

    $\fancylambda{T}{C}$ is defined inductively:
    \begin{itemize}
        \item Constant:    \[ c \in C \implies c \in \fancylambda{T}{C} \]
        \item Variable:    \[ v \in \lvars \implies v \in \fancylambda{T}{C} \]
        \item Application: \[ A, B \in \fancylambda{T}{C} \implies (AB) \in \fancylambda{T}{C} \]
        \item Abstraction: \[ v \in \lvars, A \in \fancylambda{T}{C}, \sigma \in \tclos{T}
                \implies (\lambda v : \sigma \abstr A) \in \fancylambda{T}{C} \]
        \item Construction: \[ \sigma \in T, A \in \fancylambda{T}{C}
                \implies \sigma[A] \in \fancylambda{T}{C} \]
    \end{itemize}
\end{defn}

\begin{defn}
    Derivation rules for $\lambda$-calculus with subtypes:

    \begin{itemize}
        \item Constant
            \cenderiv{
                \hypo{c \in C}
                \infer1{\Gamma \vdash c : \typeof{c}}
            }
        \item Variable
            \cenderiv{
                \hypo{x : \sigma \in \Gamma}
                \infer1{\Gamma \vdash x : \sigma}
            }
        \item Application
            \cenderiv{
                \hypo{\Gamma \vdash A : \sigma' \tot \sigma''}
                \hypo{\Gamma \vdash B : \tau}
                \hypo{\tau \less \sigma'}
                \infer3{\Gamma \vdash (AB) : \sigma''}
            }
        \item Abstraction
            \cenderiv{
                \hypo{\Gamma \circ x : \tau \vdash A : \sigma}
                \infer1{\Gamma \vdash (\lambda x : \tau \abstr A) : \tau \tot \sigma}
            }
        \item Construction via upcast
            \cenderiv{
                \hypo{\Gamma \vdash A : \sigma}
                \hypo{\sigma \less \tau}
                \infer2{\Gamma \vdash \tau[A] : \tau}
            }
        \item Construction via downcast (dangerous, doesn't need to be included in most cases)
            \cenderiv{
                \hypo{\Gamma \vdash A : \sigma}
                \hypo{\tau \less \sigma}
                \infer2{\Gamma \vdash \tau[A] : \tau}
            }
    \end{itemize}
\end{defn}

\subsubsection{Type set subsumption}
\begin{defn}
    If $T$ and $S$ are type semilattices, we say that $T \less S$ if:
    \begin{itemize}
        \item $S \subseteq T$
        \item $\forall \tau \in T \exists \sigma \in S ( \tau \less \sigma )$
    \end{itemize}

    Essentially, this says that $T$ is a specialisation of $S$: any type in
    $T$ is a more concrete variant of some type in $S$.
\end{defn}

If we have $T \less S$, it would be convenient to be able to convert between them.
The conversion from $S$ to $T$ is trivial. The conversion from $T$ to $S$,
however, involves discarding information.

\example{
    For example, let $S = \{ Int, String \}$, supposing the obvious semantics
    behind those names. This is a nice type system - however, one might want to
    be able to encode extra information within types: this comes especially
    handy in the context of CCGs.

    So, we add some extra types: \[ T = \{ Int, String, Distance, Count, NamedEntity \} \]
    We want $\less$ to be defined as \[ Distance \less Int, Count \less Int,
    NamedEntity \less String \]

    Now while doing natural language parsing, we can use $T$. Afterwards
    we no longer need the extra information, so we could discard the extra
    types and return to $S$. To do this, we define a \emph{squash function}.
}

\begin{defn}
    $\omega: T \rightarrow S$ is a \emph{squash function} for $T \less S$, if
    for each $\tau$, $\omega(\tau)$ is a minimal element in $S$ such that
    $\tau \less \omega(\tau)$.
\end{defn}

\begin{defn}
    If $\omega: T \rightarrow S$ is a squash function for $T \less S$, we can define
    $\omega_{\lambda}: \fancylambda{T}{C} \rightarrow \fancylambda{S}{C}$ inductively:
    \fixme{fill this}
\end{defn}

From here on $\omega$ will be used freely in place of $\omega_{\lambda}$.

\begin{prop}
    For a squash function $\omega: T \rightarrow S$, $\omega_{\lambda}$ is
    well-defined, namely
    \[ \Gamma \vdash M : \sigma \iff \omega(\Gamma) \vdash \omega(M) : \omega(\sigma) \]
\end{prop}
\fixme{need proof}

\subsubsection{Subtype libraries}
\begin{defn}
    A statement in the form $\sigma \lass \tau (\sigma, \tau \in \tsymbs)$
    is called a \emph{subtype assertion}.
\end{defn}

Since our definition of "subtype" doesn't allow us to subtype a complex type,
we have to work around this by making $\sigma$ be a complex type with the same
syntactic structure as $\tau$ and then subtyping on the level of individual
basic types it is made of. To do this, we need to be able to create a new term
with the same syntactic structure of another term.

\example{
    Suppose we have the basic types $Int$ and $String$, and we want to extend
    them.

    For example, take the subtype assertion $F \lass ( Int \tot String )$.
    Let $\tau = ( Int \tot String )$. We want $F$ to correspond to a type
    $\sigma$ such that $\sigma \less \tau$. To do this, we clone
    the complex type $\tau$, creating a new type with the same
    syntactic structure: $\sigma = ( Int' \tot String' )$

    Now we extend our subtyping relation to include $ Int \less Int', String' \less String $,
    which indeed gives that $\sigma \less \tau$.

    Again, take note of the argument contravariance.

    To remember that $F$ stands for $\sigma$, we will iteratively build a
    function $\varphi$ such that $\varphi(F) = \sigma$.
}

The following few definitions will formalise this process.

First, having a type $\tau$, we need to be able to create a new type
that is its clone
(has the same syntactic structure), and is a subtype of $\tau$.

To deal with contravariance, we will differentiate between a "subtype clone"
($\subtyper{clone}$),
which clones a type into a new one which will be its subtype, and a
"supertype clone", ($\suptyper{clone}$)
which does the opposite - this way we will be able to
use the $\suptyper{clone}$ in arguments and $\subtyper{clone}$ in return
values.

To do this, we will use the mappings $\subtyper{\xi}$ and $\suptyper{\xi}$
which rename the basic types used in $\tau$ into new type symbols. To clone
$\tau$, we will recursively replace argument types and return value types
with their respective clones. One way to deal with contravariance is

\newcommand\clonesub{\subtyper{clone}_{\subtyper{\xi} \suptyper{\xi}}}
\newcommand\clonesup{\suptyper{clone}_{\subtyper{\xi} \suptyper{\xi}}}

\begin{defn}
    Let $\langle T, \less \rangle$ be a type semilattice, $\tau \in \tclos{T}$
    be a type and $\subtyper{\xi}, \suptyper{\xi}$ be mappings from a
    superset of
    $\ts{\tau}$ into $\tsymbs$ such that
    $range(\suptyper{\xi}) \cap range(\subtyper{\xi}) = \varnothing$.

    $\suptyper{clone}_{\subtyper{\xi} \suptyper{\xi}}$ and
    $\subtyper{clone}_{\subtyper{\xi} \suptyper{\xi}}$ are defined by
    mutial recursion:

    \[
        \subtyper{clone}_{\subtyper{\xi} \suptyper{\xi}}(\tau) =
        \begin{cases*}
            \subtyper{\xi}(\tau)& ,
                $\tau \in T$ \\
            \suptyper{clone}_{\subtyper{\xi} \suptyper{\xi}}(\tau_1)
                \tot \subtyper{clone}_{\subtyper{\xi} \suptyper{\xi}}(\tau_2)& ,
                $\tau = \tau_1 \tot \tau_2$ \\
        \end{cases*}
    \]

    \[
        \suptyper{clone}_{\subtyper{\xi} \suptyper{\xi}}(\tau) =
        \begin{cases*}
            \suptyper{\xi}(\tau)& ,
                $\tau \in T$ \\
            \subtyper{clone}_{\subtyper{\xi} \suptyper{\xi}}(\tau_1)
                \tot \suptyper{clone}_{\subtyper{\xi} \suptyper{\xi}}(\tau_2)& ,
                $\tau = \tau_1 \tot \tau_2$ \\
        \end{cases*}
    \]

\end{defn}

\begin{defn}
    \label{def:subadd}
    Suppose we have
    \begin{itemize}
        \item a type semilattice $\langle T, \less \rangle$
        \item a type $\tau \in \tclos{T}$
        \item a type symbol$\sigma \in \tsymbs \setminus T$
        \item a mapping $\varphi$ with $range(\varphi) = \tclos{T}$
    \end{itemize}
    Let $\suptyper{\xi}$ and $\subtyper{\xi}$ be injections from
    $\ts{\tau}$ into $\tsymbs \setminus (T \cup \{ \sigma \})$ such that
    $range(\suptyper{\xi}) \cap range(\subtyper{\xi}) = \varnothing$\footnote{
        $\suptyper{\xi}$ and $\subtyper{\xi}$ depend on $\tau$, $T$ and
        $\sigma$. If one wants to make their choice constrictive, they may,
        for example, assume that $\tsymbs$ is ordered, take the minimal
        elements that aren't in $T \cup \{ \sigma \}$ and map to them in
        order.
    }.

    Now define the operation $\tadd$ as:
        \[ \langle \langle T, \less \rangle, \varphi \rangle
            \tadd (\sigma \lass \tau)
            \defeq
            \langle \langle T', \less' \rangle, \varphi' \rangle
        \] where:
    \begin{itemize}
        \item $\rho = \clonesub(\tau)$
        \item $T' = T \cup ((range(\subtyper{\xi}) \cup range(\suptyper{\xi})) \cap \ts{\rho})$
        \item $\less'$ is the transitive and reflexive closure of
            $\less \cup \{ (\sigma', \tau') \in T' \times T' \mid \subtyper{\xi}(\tau') = \sigma' \}
                   \cup \{ (\sigma', \tau') \in T' \times T' \mid \suptyper{\xi}(\sigma') = \tau' \}$
        \item $\varphi' = \varphi \cup \{ \rho \}$
    \end{itemize}
\end{defn}

\begin{defn}
    A finite sequence of subtype assertions
    $\Theta_T = \theta_1 ... \theta_n$ is called a \emph{subtype library} over $T$
    if $\hat{\Theta}_T = \langle \langle T, \less \rangle, \emptyset \rangle \oplus \theta_1 \oplus \theta_2 ... \oplus \theta_n$
    is defined\footnote{
        When trying to redefine a previously defined type, the sequence is not
        a subtype library because of the restriction for $\sigma$
        in \cref{def:subadd}.
    }.

    Also, we can define the function which gives us all the new type names
    asserted by the subtype library as
    $left(\Theta_T) = \{ \sigma \mid \sigma \lass \tau \in \Theta \}$
\end{defn}

\begin{prop}
    If $T$ is a type semilattice and
    $\Theta_T = \theta_1 ... \theta_n$ is a subtype library over $T$, where
    $\hat{\Theta}_T = \langle \langle T', \less' \rangle, \varphi \rangle$
    the following properties hold:
    \begin{itemize}
        \item $\varphi : left(\Theta) \rightarrow \tclos{T'}$
        \item $\sigma \less \tau \implies \sigma \less' \tau$
        \item $\sigma \lass \tau \in \Theta \implies \varphi(\sigma) \less \hat{\varphi}(\tau)$
    \end{itemize}
\end{prop}
\fixme{need proof}

\begin{prop}
    If $T$ is a type semilattice and
    $\Theta_T = \theta_1 ... \theta_n$ is a subtype library over $T$, where
    $\hat{\Theta}_T = \langle \langle T', \less' \rangle, \varphi \rangle$,
    then $T' \less T$. Even more, there is a unique squash function
    $\omega_{\Theta} : T' \rightarrow T$.
\end{prop}
\fixme{need proof!}


\subsubsection{Type propagation}
\label{sec:propagation}
For the sake of performing optimisations, it is convenient to store extra
information within types. For example, we can extend our $Num$ type to include
a tag which says whether the value this type is attached to is a constant. This
information can then be used to prune entire subterms whose value is constant.

In order to manipulate subterm types easily, we will introduce a construction
called \emph{type-tagged $\lambda$-terms}, which essentially means attaching
a type to every subterm.

This construction doesn't need to include casts, since we are storing
a type for every subterm anyway, which can replace the use of casts for all
practical\footnote{
    There is no way to preserve multiple consecutive casts. Note that if the
    type system doesn't allow cross-branch casts, extra measures need to be taken
    to preserve the validity of terms in $\mcf{untag}$: e.g. if we have a
    term $M$ with a type tag $\sigma$ and an actual type $\tau$ where for some $\eta$,
    $\eta \less \sigma, \eta \less \tau$ but $\sigma$ and $\tau$ aren't comparable,
    we must yield $\sigma[\eta[M]]$ instead of $\sigma[M]$.
} cases. There is also no need for storing the types of bound variables, since
they can be easily extracted from the types of the respective abstraction terms.
\begin{defn}
    Let $C \subset \const$ be a set of constants, typed in $T$.

    $\ttlambda{T}{C}$ is defined inductively:
    \begin{itemize}
        \item Constant:
            \[ c \in C, \tau \in \tclos{T} \implies \ttt{c}{\tau} \in \ttlambda{T}{C} \]
        \item Variable:
            \[ v \in \lvars, \tau \in \tclos{T} \implies \ttt{v}{\tau} \in \ttlambda{T}{C} \]
        \item Application:
            \[ A, B \in \ttlambda{T}{C}, \tau \in \tclos{T} \implies \ttt{(AB)}{\tau} \in \ttlambda{T}{C} \]
        \item Abstraction:
            \[ v \in \lvars, A \in \ttlambda{T}{C}
                \tau = (\tau' \tot \tau'') \in \tclos{T},
                \implies \ttt{(\lambda v \abstr A)}{\tau} \in \ttlambda{T}{C} \]
    \end{itemize}
\end{defn}

Converting regular $\lambda$-terms into type-tagged $\lambda$-terms is
relatively straightforward: simply examine the type of every subterm according
to its local context and then store it into the tag.
\begin{defn}
    For a context $\Gamma$,
    $\mcf{tag}_{\Gamma} : \fancylambda{T}{C} \rightarrow \ttlambda{T}{C}$
    is defined inductively:
    \[
        \mcf{tag}_{\Gamma}(A) =
        \begin{cases*}
            \ttt{c}{\typeof{C}} &,  $A = c \in C$ \\
            \ttt{v}{\tau} &, $A = v \in \lvars, \Gamma \vdash v : \tau$ \\
            \ttt{(\mcf{tag}_{\Gamma}(M) \app \mcf{tag}_{\Gamma}(N))}{\tau}
                &, $A = (MN), \Gamma \vdash A : \tau$ \\
            \ttt{\lambda v \abstr \mcf{tag}_{\Gamma'}(M)}{\sigma \tot \tau}
                &, $A = (\lambda v: \sigma \abstr M)
                 , \Gamma' \vdash M : \tau
                 , \Gamma' = \Gamma \circ v : \sigma$\\
            \ttt{M}{\tau} &, $A = \tau[M]$ \\
        \end{cases*}
    \]
\end{defn}

Since the type tags of (sub)terms may not match their inferred type,
we need a wrapping function that inserts casts when needed.
\begin{defn}
    For a context $\Gamma$,
    $\mcf{untag}_{\Gamma} : \ttlambda{T}{C} \rightarrow \fancylambda{T}{C}$
    and
    $\mcf{untag'}_{\Gamma} : \ttlambda{T}{C} \rightarrow \fancylambda{T}{C}$
    are defined inductively:
    \[
        \mcf{untag'}_{\Gamma}(\ttt{A}{\tau}) =
        \begin{cases*}
            c &, $A = c \in C$ \\
            v &, $A = v \in \lvars$ \\
            \mcf{untag}_{\Gamma}(P) \app \mcf{untag}_{\Gamma}(Q)
                &, $A = (PQ)$ \\
            \lambda v : \tau' \abstr \mcf{untag}_{\Gamma'}(P)
                &, $A = (\lambda v \abstr P), \tau = (\tau' \tot \tau'')
                 , \Gamma' = \Gamma \circ v : \tau'$ \\
        \end{cases*}
    \]

    \[
        \mcf{untag}_{\Gamma}(\ttt{A}{\tau}) =
        \begin{cases*}
            M &, $M = \mcf{untag'}_{\Gamma}(\ttt{A}{\tau}), \Gamma \vdash M : \tau$ \\
            \tau[M] &, $M = \mcf{untag'}_{\Gamma}(\ttt{A}{\tau}), \Gamma \not\vdash M : \tau$ \\
        \end{cases*}
    \]
\end{defn}

Now that we have the construction for attaching types to subterms, we can
describe a universal way to propagate information through those types.

We will use a basic operation $\unify : \tclos{T} \times \tclos{T} \rightarrow \tclos{T}$
which unifies two types.

It can also be extended for contexts in the following way:
\[
    \begin{split}
        \Gamma' \unify \Gamma'' \defeq
        &\{ (x : \sigma \unify \tau) \mid (x : \sigma) \in \Gamma', (x : \tau) \in \Gamma''\} \\
        \cup &
        \{ (x : \sigma) \mid (x : \sigma) \in (\Gamma' \cup \Gamma''),
            (x : \cdot) \not\in \Gamma',
            (x : \cdot) \not\in \Gamma'' \} \\
    \end{split}
\]

\fixme{incomplete}

Now, type propagation will be done in two steps: upward (propagating
information up the term tree and into the context) and downward (propagating
information down the term tree towards the leaves).

\begin{defn}
    \[
        \mcf{up}(\ttt{A}{\tau}) =
        \begin{cases*}
            (\ttt{c}{\tau}, \{ \}) &, $A = c \in C$ \\
            (\ttt{v}{\tau}, \{ v : \tau \}) &, $A = v \in \lvars$ \\
            (\ttt{\lambda x \abstr \ttt{M}{\sigma'}}{(\eta' \unify \eta) \tot (\sigma' \unify \sigma)}, \Gamma')
                &, $A = (\lambda x \abstr P)
                , \tau = (\eta \tot \sigma),$ \\
                \phantom{} &\phantom{, }$(\ttt{M}{\sigma'}, \Gamma) = \mcf{up}(P)
                , \Gamma' = \Gamma \setminus (x : \eta'),$ \\
                \phantom{} &\phantom{, }$(x : \eta') \in \Gamma$ \\
            (\ttt{\lambda x \abstr \ttt{M}{\sigma'}}{\eta \tot (\sigma' \unify \sigma)}, \Gamma')
                &, $A = (\lambda x \abstr P)
                , \tau = (\eta \tot \sigma),$ \\
                \phantom{} &\phantom{, }$(\ttt{M}{\sigma'}, \Gamma) = \mcf{up}(P)$ \\
                \phantom{} &\phantom{, }$(x : \cdot) \not\in \Gamma$ \\
            (\ttt{P' Q'}{\sigma'' \unify \tau}, \Gamma_P \unify \Gamma_Q)
                &, $A = (PQ), (P', \Gamma_P) = \mcf{up}(P),$ \\
                \phantom{} &\phantom{, }$(Q', \Gamma_Q) = \mcf{up}(Q), P' = \ttt{M}{\sigma' \tot \sigma''}$ \\
        \end{cases*}
    \]
    \[
        \mcf{down}(\ttt{A}{\tau}, \tau', \Gamma) =
        \begin{cases*}
            \ttt{c}{\tau \unify \tau'} &, $A = c \in C$ \\
            \ttt{v}{\tau \unify \tau' \unify \tau''}
                &, $A = v \in \lvars, (v : \tau'') \in \Gamma$ \\
            \ttt{\lambda x \abstr P'}{\eta'' \tot \sigma''}
                &, $A = \ttt{P}{\sigma}, P' = \mcf{down}(P, \sigma'', \Gamma \circ (x : \eta'')),$ \\
                \phantom{} &\phantom{, }$\tau = (\eta \tot \sigma),
                \tau' = (\eta' \tot \sigma'),$ \\
                \phantom{} &\phantom{, }$\sigma'' = (\sigma \unify \sigma'),
                \eta'' = (\eta \unify \eta')$ \\
            \ttt{P' Q'}{\tau''}
                &, $A = (PQ), P = \ttt{M}{\sigma \tot \eta}, Q = \ttt{N}{\sigma'},$ \\
                \phantom{} &\phantom{, }$\tau'' = (\tau' \unify \tau), \sigma'' = (\sigma' \unify \sigma)$ \\
                \phantom{} &\phantom{, }$P' = \mcf{down}(P, (\sigma' \tot \tau''), \Gamma),
                Q' = \mcf{down}(Q, \sigma'', \Gamma)$ \\
        \end{cases*}
    \]
\end{defn}
\end{document}
