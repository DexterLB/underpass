\documentclass[main.tex]{subfiles}
\begin{document}

\subsection{Simply typed $\lambda$-calculus}

For representing compositional terms, a version of simply typed lambda calculus
will be used.

\subsubsection{Types}
\begin{defn}
    A set $T$ is a \emph{meet-semilattice with top and bottom} when:
    \begin{itemize}
        \item the partial order relation
            $\less \subseteq T \times T$ is defined
        \item the operator $\meet : T \times T \rightarrow T$ is defined
        \item $\top \in T, \bot \in T$
        \item For any $\sigma, \tau, \nu \in T$:
            \begin{itemize}
                \item $(\sigma \meet \tau) \meet \nu = \sigma \meet (\tau \meet \nu)$
                \item $\sigma \meet \tau = \tau \meet \sigma$
                \item $\sigma \meet \tau = \nu \implies \nu \less \sigma$
                \item $\sigma \meet \tau = \nu \implies \nu \less \tau$
                \item $\sigma \meet \sigma = \sigma$
                \item $\sigma \meet \top = \top \meet \sigma = \sigma$
                \item $\sigma \meet \bot = \bot \meet \sigma = \bot$
                \item $\sigma \less \top$, $\bot \less \sigma$
            \end{itemize}
    \end{itemize}

\end{defn}

\begin{defn}
    A set $T$ is a \emph{type semilattice} when:
    \begin{itemize}
        \item For any $\sigma, \tau \in T$, $(\sigma \tot \tau) \in T$
        \item $T$ is a bounded meet-semilattice with top and bottom.
    \end{itemize}

    For convenience, the $\rightarrow$ operator will be regarded as
    right-associative.
\end{defn}

\begin{defn}
    For a meet-semilattice with top and bottom $T$, we can define the
    \emph{type closure} $\mathcal{T}(T)$ and extend $\less$ and $\meet$ as follows:
    \begin{itemize}
        \item $\sigma \in T \implies \sigma \in \mathcal{T}(T)$
        \item $(\sigma' \rightarrow \tau'), (\sigma'' \rightarrow \tau'') \in
            \mathcal{T}(T) \implies
            (\sigma' \rightarrow \tau') \less (\sigma'' \rightarrow \tau'')
            \Leftrightarrow
            (\sigma' \less \sigma'') \& (\tau' \less \tau'')$
        \item $(\sigma' \rightarrow \tau'), (\sigma'' \rightarrow \tau'') \in
            \mathcal{T}(T) \implies
            (\sigma' \rightarrow \tau') \meet (\sigma'' \rightarrow \tau'')
            =
            (\sigma' \meet \sigma'') \rightarrow (\tau' \meet \tau'')$
        \item $(\sigma' \rightarrow \sigma'') \in \mathcal{T}(T), \tau \in T
            \implies (\sigma' \rightarrow \sigma'') \meet \tau
            = \tau \meet (\sigma' \rightarrow \sigma'') = \bot$
    \end{itemize}
\end{defn}
\begin{prop}
    If $T$ is a meet-semilattice with top and bottom, $\mathcal{T}(T)$ is
    a type semilattice.
\end{prop}

\begin{defn}
    We call a set $X$ \emph{typed in} $T$ $\iff$ there is a function
    \[ typeof : X \rightarrow T \] and $T$ is a type semilattice.
\end{defn}

\subsubsection{Terms}
To define $\lambda$ terms with the types introduced above, a system similar
to Church's $\lambda_\rightarrow$ \cite[chap.~2.4]{ttfp} shall be used. It
extends the original system with constants and constructors.

\begin{defn}
    Let $\mathbb{V}$ be an infinite countable set. We shall call its elements
    \emph{variables}.
\end{defn}

\begin{defn}
    Let $C$ be a countable set, typed in $T$,
    whose elements we call \emph{constants}.

    For a type semilattice $T$, we can define the set of
    \emph{pre-typed $\lambda$-terms} ($\Lambda_T^C$).

    \begin{itemize}
        \item Constant:    \[ c \in C \implies c \in \Lambda_T^C \]
        \item Variable:    \[ v \in \mathbb{V} \implies v \in \Lambda_T^C \]
        \item Application: \[ A, B \in \Lambda_T^C \implies (AB) \in \Lambda_T^C \]
        \item Abstraction: \[ v \in \mathbb{V}, A \in \Lambda_T^C, \sigma \in T
                \implies (\lambda v : \sigma \abstr A) \in \Lambda_T^C \]
        \item Construction: \[ \sigma \in T, A \in \Lambda_T^C
                \implies \sigma[A] \in \Lambda_T^C \]
    \end{itemize}
\end{defn}

\begin{defn}
    Statement, declaration, context, judgement
    \begin{itemize}
        \item For $M \in \Lambda_T^C, \sigma \in T$, $M : \sigma$ is called
            a \emph{statement}. $M$ is called a \emph{subject} and $\sigma$
            is called a \emph{type}.
        \item A statement with a variable as a subject is called a \emph{declaration}.
        \item A set of declarations with different subjects is called a \emph{context}.
        \item A \emph{judgement} has the form $\Gamma \vdash M: \sigma$, where
            $\Gamma$ is a context and $M: \sigma$ is a statement.
    \end{itemize}

    Moreover, appending to contexts is defined as follows:
    \[ \Gamma \circ x : \sigma = \{ y : \tau \in \Gamma \mid y \neq x \}
       \cup \{ x : \sigma \} \]
\end{defn}

\begin{defn}
    To define what it means for a term $M \in \Lambda_T^C$ to have a type,
    we will use derivation rules.
    \begin{itemize}
        \item Constant
            \cenderiv{
                \hypo{c \in C}
                \infer1{\Gamma \vdash x : typeof(c)}
            }
        \item Variable
            \cenderiv{
                \hypo{x : \sigma \in \Gamma}
                \infer1{\Gamma \vdash x : \sigma}
            }
        \item Application
            \cenderiv{
                \hypo{\Gamma \vdash A : \sigma}
                \hypo{\Gamma \vdash B : \tau}
                \hypo{\sigma \meet (\tau \tot \top) = (\nu' \tot \nu'')}
                \infer3{\Gamma \vdash (AB) : \nu''}
            }
        \item Abstraction
            \cenderiv{
                \hypo{\Gamma \circ x : \tau \vdash A : \sigma}
                \infer1{\Gamma \vdash (\lambda x : \tau \abstr A) : \tau \tot \sigma}
            }
        \item Construction via downcast
            \cenderiv{
                \hypo{\Gamma \vdash A : \sigma}
                \hypo{\tau \less \sigma}
                \infer2{\Gamma \vdash \tau[A] : \tau}
            }
        \item Construction via upcast (dangerous, doesn't need to be included in most cases)
            \cenderiv{
                \hypo{\Gamma \vdash A : \sigma}
                \hypo{\sigma \less \tau}
                \infer2{\Gamma \vdash \tau[A] : \tau}
            }
    \end{itemize}

    Now, $typeof(M)$ for $M \in \Lambda_T^C$ is defined as such:
    \[
        typeof(M) =
        \begin{cases*}
            \sigma & if $\varnothing \vdash M : \sigma$ \\
            \neg ! & otherwise
        \end{cases*}
    \]
    Of course, the above function is nowhere defined for non-closed terms.
\end{defn}

\begin{defn}
    A term is \emph{subtype-sound}, if for every subterm $M$
    ($\Gamma \vdash M : \sigma$) and local context
    $\Gamma_M$ the following apply:
    \begin{itemize}
        \item $\bot \not \in \sigma$
        \item if $M = (AB), \Gamma_M \vdash A : \sigma, \Gamma_M \vdash B : \tau,
            \sigma \meet (\tau \tot \top) = (\nu' \tot \nu'')$, then
            $\tau \less \nu'$
    \end{itemize}
\end{defn}

\end{document}
