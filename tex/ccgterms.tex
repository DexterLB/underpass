\documentclass[main.tex]{subfiles}
\begin{document}
\subsection{Semantics within CCG}

\subsubsection{Extracting $\lambda$-terms from CCG derivations}

A great strength of CCG comes from the ability to directly construct $\lambda$-terms
from CCG derivations. This relies on the assumption that the target
language has a compositional nature, namely that the semantics of any construction
can be determined by composing the semantics of its constituents.

So, we shall to provide the semantics for the basic blocks (in our case
the elements of $\Sigma$) in the form of $\lambda$-terms, and then define rules
for composing those terms in accordance with a CCG derivation tree.

\begin{defn}
    For a set of basic categories $N$ typed in $\Theta$, we can define
    \[ typeof : C(N) \rightarrow \tclos{\Theta} \]
    in the following way:

    \[
        typeof(Z) =
        \begin{cases*}
            typeof(Z), & $Z \in N$ \\
            Y \tot X,  & $Z = \lp X \lc Y \rp$ \\
            Y \tot X,  & $Z = \lp X \rc Y \rp$ \\
        \end{cases*}
    \]

    This gives meaning to categories in the context of $\lambda$-calculus:
    $\lp X \lc Y \rp$ refers to a function which returns a value of type
    $X$ and takes an argument of type $Y$ \emph{on the right side}, while
    $\lp X \lc Y \rp$ refers to a function which returns a value of type
    $X$ and takes an argument of type $Y$ \emph{on the left side}.
\end{defn}

Now that we've given types to categories, we can attach $\lambda$-terms
to each terminal in addition to the categories we've attached via the function
$f$. This will give us $\lambda$-terms in the leaves of each derivation tree,
which can be composed naturally into $\lambda$-terms for all subtrees including
the whole tree, giving us the semantic information for this parse.

To do this, we will use a function that maps each terminal/category pair
to a $\lambda$-term. In order for the terms constructed on derivation trees
to be correct and consistent, we will also want the terms of each node to be
of the same type as its category.

\begin{defn}
    Let $ G = \langle \Sigma, N, S, f, n \rangle $ be a CCG, $N$ be
    a set of categories typed in $T$ and $C$ be a set
    of constants typed in $\Theta$.
    A function
    \[ \psi : \{ (a, X) \mid a \in \Sigma, X \in f(a) \} \rightarrow 2^{\Lambda_{\Theta}^C} \] is called a
    \emph{semantic function} for G.

\end{defn}

\begin{defn}
    Let $G$ be a CCG, $\psi$ be a semantic function for $G$ and $T$ be a
    derivation tree for $G$.

    We will inductively define $sem_{\psi}(T) \subset \Lambda_{\Theta}^C$ with
    respect to $T$:
    \begin{itemize}
        \item If $T$ is
            \begin{center}
                \begin{tikzpicture}[node distance=1mm,sibling distance=1cm]
                    \Tree[
                        .\node(outtop){$X$};
                            \edge[very thick];
                            [ .\node(in){$a$};
                            ]
                    ]
                    \node[boxcolb,fit=(outtop)(in)](outbox){};
                    \node[right=of outbox,text=\boxtextb](outlabel){$T$};
                \end{tikzpicture}
            \end{center}
            and $X \in f(a)$, then
            \[ sem_{\psi}(T) = \psi(a, X) \]
        \item If $T$ is
            \begin{center}
                \begin{tikzpicture}[node distance=1mm,sibling distance=1cm]
                    \Tree[
                        .\node(outtop){$X \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m$};
                            \edge[very thick];
                            [ .\node(intopl){$X \rc Y$};
                                \edge[roof];
                                [ .\node(inbotl){$\alpha$}; ]
                            ]
                            [ .\node(intopr){$Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m$};
                                \edge[roof];
                                [ .\node(inbotr){$\alpha$}; ]
                            ]
                    ]
                    \node[boxcola,fit=(intopl)(inbotl)](inboxl){};
                    \node[left=of inboxl,text=\boxtexta](inlabell){$T_1$};

                    \node[boxcola,fit=(intopr)(inbotr)](inboxr){};
                    \node[right=of inboxr,text=\boxtexta](inlabelr){$T_2$};

                    \node[boxcolb,fit=(outtop)(inbotl)(inboxl)(inboxr)(inlabell)(inlabelr)](outbox){};
                    \node[right=of outbox,text=\boxtextb](outlabel){$T$};
                \end{tikzpicture}
            \end{center}
            where $root(T_1) = X \rc Y$ and $root(T_2) = Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m$ then
            \[ sem_{\psi}(T) = \lambda z_m {:} \typeof{Z_m}, z_{m - 1} {:} \typeof{Z_{m - 1}}, ..., z_1 {:} \typeof{Z_1} \abstr
                sem_{\psi}(T_1) ( sem_{\psi}(T_2) z_m z_{m - 1} ... z_1 ) \]
            for $z_1 ... z_m \not\in fv(sem_{\psi}(T_1)) \cup fv(sem_{\psi}(T_2))$
        \item If $T$ is
            \begin{center}
                \begin{tikzpicture}[node distance=1mm,sibling distance=1cm]
                    \Tree[
                        .\node(outtop){$X \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m$};
                            [ .\node(intopl){$Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m$};
                                \edge[roof];
                                [ .\node(inbotl){$\alpha$}; ]
                            ]
                            \edge[very thick];
                            [ .\node(intopr){$X \lc Y$};
                                \edge[roof];
                                [ .\node(inbotr){$\alpha$}; ]
                            ]
                    ]
                    \node[boxcola,fit=(intopl)(inbotl)](inboxl){};
                    \node[left=of inboxl,text=\boxtexta](inlabell){$T_1$};

                    \node[boxcola,fit=(intopr)(inbotr)](inboxr){};
                    \node[right=of inboxr,text=\boxtexta](inlabelr){$T_2$};

                    \node[boxcolb,fit=(outtop)(inbotl)(inboxl)(inboxr)(inlabell)(inlabelr)](outbox){};
                    \node[right=of outbox,text=\boxtextb](outlabel){$T$};
                \end{tikzpicture}
            \end{center}
            where $root(T_1) = Y \mc_1 Z_1 \mc_2 Z_2 ... \mc_m Z_m$ and $root(T_2) = X \lc Y$ then
            \[ sem_{\psi}(T) = \lambda z_m {:} \typeof{Z_m}, z_{m - 1} {:} \typeof{Z_{m - 1}}, ..., z_1 {:} \typeof{Z_1} \abstr
                sem_{\psi}(T_2) ( sem_{\psi}(T_1) z_m z_{m - 1} ... z_1 ) \]
            for $z_1 ... z_m \not\in fv(sem_{\psi}(T_1)) \cup fv(sem_{\psi}(T_2))$
    \end{itemize}
\end{defn}

\begin{defn}
    A semantic function $\psi$ is called \emph{consistent with} a context
    $\Gamma$ when
    \[
        \forall a, X: M \in \psi(a, X) \implies \Gamma \vdash M : \typeof{X}
    \]
\end{defn}

\begin{prop}
    \label{ccg:typeconsistent}
    If $ G = \langle \Sigma, N, S, f, n \rangle $ is a CCG and $\psi$ is a
    semantic function for $G$ that is consistent with $\Gamma$, then
    for every valid derivation tree $T$, $sem_{\psi}$ is well-defined (contains
    only correct $\lambda$-terms in $\Lambda_N^C$). Moreover, for any valid
    derivation tree $T$:
    \[
        M \in sem_{\psi}(T) \implies \Gamma \vdash M : \typeof{root(T)}
    \]
\end{prop}

Given proposition \autoref{ccg:typeconsistent}, we know that all terms generated
from CCG derivation trees will be consistent.

\end{document}
