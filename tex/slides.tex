\documentclass[10pt]{beamer}
\usepackage[english,bulgarian]{babel}
\input{./macros.tex}
% \usetheme{Copenhagen}
\usecolortheme{dove}
\title{Катег\'орийни граматики за геопространствени заявки}
\date{\today}
\author{Бла Бла}
\institute{Магистър университет ФМИ бла}
\begin{document}
  \maketitle

  \section{Геопространствени заявки}
  \begin{frame}[fragile]
    Вход:
    \begin{lstwrap}\begin{lstlisting}
      pharmacies near parking spaces in Berlin
    \end{lstlisting}\end{lstwrap}
    Изход:

    \includegraphics[width=0.32\textwidth]{map/world.png}
    \hfill
    \includegraphics[width=0.32\textwidth]{map/berlin.png}
    \hfill
    \includegraphics[width=0.32\textwidth]{map/pharmacy.png}
  \end{frame}

  \section{Overpass}
  \begin{frame}[fragile]{Overpass код}
    \begin{lstwrap}\begin{lstlisting}
    ( node["amenity" = "parking_space"]; ) -> .x1;
    ( area["name" = "Berlin"]; area["int_name" = "Berlin"]; area["name:en" = "Berlin"]; ) -> .x2;
    ( node(area.x2)(around.x1:100.0)["amenity" = "pharmacy"]; ) -> .x3;
    .x3 out;
    \end{lstlisting}\end{lstwrap}
  \end{frame}

  \begin{frame}{Типове обекти в Overpass}
    \begin{itemize}
      \item node
      \item way
      \item relation
      \item area
    \end{itemize}
  \end{frame}

  \begin{frame}{Set}

  \end{frame}

  \begin{frame}[fragile]{Резултат от заявка}
    \begin{lstwrap}\begin{lstlisting}
        out <input set>;
    \end{lstlisting}\end{lstwrap}
  \end{frame}

  \begin{frame}[fragile]{Извличане на обекти}
    \begin{itemize}
      \item Синтаксис
        \begin{lstwrap}\begin{lstlisting}
            <object keyword><filter><filter>...<filter>
        \end{lstlisting}\end{lstwrap}
      \item Пример
        \begin{lstwrap}\begin{lstlisting}
            node[name="Foo"];
            out;
        \end{lstlisting}\end{lstwrap}
        \begin{lstwrap}\begin{lstlisting}
            node[name="Foo"] -> ._;
            out ._;
        \end{lstlisting}\end{lstwrap}
    \end{itemize}
  \end{frame}

  \begin{frame}[fragile]{Извличане на обекти}
    \begin{itemize}
      \item Синтаксис
        \begin{lstwrap}\begin{lstlisting}
            <keyword><filter><filter>...<filter>
        \end{lstlisting}\end{lstwrap}
      \item Ключови думи
        \begin{center}
            \begin{tabular}{r|l}
                \code{node} & retrieves nodes \\
                \code{way} & retrieves ways \\
                \code{relation} & retrieves relations \\
                \code{area} & retrieves areas \\
                \code{nwr} & retrieves nodes, ways, and relations \\
            \end{tabular}
        \end{center}
    \end{itemize}
  \end{frame}

  \begin{frame}[fragile]{Други филтри за ``тагове''}
    \begin{lstwrap}\begin{lstlisting}
        node[amenity="cafe"];
    \end{lstlisting}\end{lstwrap}

    \begin{lstwrap}\begin{lstlisting}
        node[amenity="cafe"][name="Moondeers"];
    \end{lstlisting}\end{lstwrap}

    \begin{lstwrap}\begin{lstlisting}
        node[amenity="cafe"][name~"^moondeers$",i];
    \end{lstlisting}\end{lstwrap}

    \begin{lstwrap}\begin{lstlisting}
        area["administrative"];
    \end{lstlisting}\end{lstwrap}
  \end{frame}

  \begin{frame}[fragile]{Сечение}
      \begin{lstwrap}\begin{lstlisting}
          node[amenity="cafe"] -> .cafes;
          node.cafes;
      \end{lstlisting}\end{lstwrap}
      \begin{lstwrap}\begin{lstlisting}
          node[amenity="cafe"] -> .cafes;
          node.cafes[name="Moondeers"];
      \end{lstlisting}\end{lstwrap}
  \end{frame}

  \begin{frame}[fragile]{Обекти в area}
    \begin{lstwrap}\begin{lstlisting}
      area[name="Frankfurt"] -> fr;
      node(area.fr);
      out;
    \end{lstlisting}\end{lstwrap}
  \end{frame}

  \begin{frame}[fragile]{Обекти на разстояние от други обекти}
    \begin{lstwrap}\begin{lstlisting}
        node[amenity="parking_space"] -> pspaces;
        node[amenity="cafe"](around.pspaces:120) -> x;
        out x;
    \end{lstlisting}\end{lstwrap}
    \begin{lstwrap}\begin{lstlisting}
        area[name="Bonn"];
        node(area)[highway=bus_stop];
        node(around:100)[amenity=cinema];
        out;
    \end{lstlisting}\end{lstwrap}
  \end{frame}

  \begin{frame}[fragile]{Обединение}
    \begin{lstwrap}\begin{lstlisting}
        node[amenity="cafe"] -> .cafes;
        area[name="Bonn"] -> .bonn;
        area[name="Frankfurt"] -> .frankfurt;
        node.cafes(area.bonn) -> .cb;
        node.cafes(area.frankfurt) -> .cf;
        (.cf; .cb;) -> .cfb;
        out .cfb;
    \end{lstlisting}\end{lstwrap}

    \begin{lstwrap}\begin{lstlisting}
        area[name="Bonn"] -> .bonn;
        area[name="Frankfurt"] -> .frankfurt;
        ( node[amenity="cafe"](area.bonn); node[amenity="cafe"](area.frankfurt); );
        out;
    \end{lstlisting}\end{lstwrap}
  \end{frame}

  \section{Категорийни граматики}
  \begin{frame}{Категорийни граматики: пример}
    \gramshort{
        \gramrow{pharmacies}{ GSet }{}
        \gramrow{Berlin}{ GSet }{}
    }
  \end{frame}
  \begin{frame}{Категорийни граматики: пример}
    \gramshort{
        \gramrow{pharmacies}{ GSet }{}
        \gramrow{Berlin}{ GSet }{}
        \gramrow{parking}{ GSet \rc Spaces }{}
        \gramrow{spaces}{Spaces}{}
    }
  \end{frame}
  \begin{frame}{Категорийни граматики: пример}
    \gramshort{
        \gramrow{pharmacies}{ GSet }{}
        \gramrow{Berlin}{ GSet }{}
        \gramrow{parking}{ GSet \rc Spaces }{}
        \gramrow{spaces}{Spaces}{}
        \gramrow{in}{ (GSet \lc GSet) \rc GSet }{}
        \gramrow{near}{ (GSet \lc GSet) \rc GSet }{}
    }
  \end{frame}
  \begin{frame}{Категорийни граматики: пример}
    \autoscaledtree{.{$GSet$}
        [ .{$GSet$}
            [ .{$GSet$} [ .{$pharmacies$} ] ]
            \edge[very thick];
            [ .{$GSet \lc GSet$}
                \edge[very thick];
                [ .{$(GSet \lc GSet) \rc GSet$} [ .{$near$} ] ]
                [ .{$GSet$}
                    \edge[very thick];
                    [ .{$GSet \rc Spaces$} [ .{$parking$} ] ]
                    [ .{$Spaces$} [ .{$spaces$} ] ]
                ]
            ]
        ]
        \edge[very thick];
        [ .{$GSet \lc GSet$}
            \edge[very thick];
            [ .{$(GSet \lc GSet) \rc GSet$} [ .{$in$} ] ]
            [ .{$GSet$} [ .{$Berlin$} ] ]
        ]
    }
  \end{frame}

  \section{Minipass: междинен език}
  \begin{frame}{Графова абстракция}
    \begin{itemize}
      \item Върхове: Overpass обекти
        \begin{itemize}
          \item по тип
          \item по стойност на таг (например име)
          \item ...
        \end{itemize}
      \item Ребра: връзки между обектите \pika
        \begin{itemize}
          \item близост
          \item физическо съдържане
          \item ...
        \end{itemize}
    \end{itemize}
  \end{frame}

  \begin{frame}[fragile]{Графова абстракция: пример}
    Заявка:
    \begin{lstwrap}\begin{lstlisting}
      bus stops near schools in Russia
    \end{lstlisting}\end{lstwrap}

    \begin{enumerate}
      \item Нека $B$ е множеството от върховете, имащи етикет
        ``е автобусна спирка''
      \item Нека $S$ е множеството от върховете, имащи етикет
        ``е училище''
      \item Нека $R$ е множеството от върховете, имащи етикет
        ``английското му име е \emph{Russia}''
      \item Нека $N$ е множеството от върховете, които можем да
        достигнем от върхове в $S$, ходейки по ребро, имащо етикет
        ``е близо до''
      \item Нека $P$ е множеството от върховете, които можем да
        достигнем от върхове в $R$, ходейки по ребро, имащо етикет
        ``е във вътрешността на''
      \item Резултатът е $B \cap N \cap P$.
    \end{enumerate}
  \end{frame}

  \begin{frame}{Синтаксис: Основни типове}
    \begin{itemize}
      \item $Num$ - цяло число \pika
      \item $String$ - низ \pika
      \item $List$ - полиморфен свързан списък, който може
        да съдържа $Num$, $String$ и $List$
      \item $GSet$ - множество от географски обекти: съответства на \code{Set}
        в Overpass
    \end{itemize}
  \end{frame}

  \begin{frame}{Синтаксис: $\lambda$}
    \begin{itemize}
      \item Прилагане на термове (ляво-асоциативно)
        \begin{center}
          \code{<term1> <term2>}
        \end{center}
      \item Абстракция
        \begin{center}
          \code{lambda <varname> : <type> => <term>}
        \end{center}
      \item Променливи и константи
      \item Сложни типове
        \begin{center}
          \code{<type1> -> <type2>}
        \end{center}
    \end{itemize}
  \end{frame}

  \begin{frame}{Синтаксис: ключови думи}
    \begin{center}
      \begin{tabular}{r l p{0.35\textwidth}}
        Идентификатор  & Тип & \\
        \hline
        \code{and}  & $GSet \tot GSet \tot GSet$ & сечение \cendrow
        \code{or}   & $GSet \tot GSet \tot GSet$ & обединение \cendrow
        \code{not}  & $GSet \tot GSet$ & допълнение \cendrow
        \hline
        \code{get}  & $List \tot GSet$ & извличане на географски обекти по
        етикет на връх \cendrow
        \code{next} & $List \tot GSet \tot GSet$ & извличане на географски обекти
        траверсирайки ребро \cendrow
      \end{tabular}
    \end{center}
  \end{frame}
  \begin{frame}{Синтаксис: ключови думи за списъци}
    \begin{center}
      \begin{tabular}{r l p{0.35\textwidth}}
        Идентификатор  & Тип & \\
        \hline
        \code{empty} & $List$ & празен списък \cendrow
        \code{consNum} & $Num \tot List \tot List$ & залепяне на число
        в началото на списък \cendrow
        \code{consString} & $String \tot List \tot List$ & залепяне на низ
        в началото на списък \cendrow
        \code{consList} & $List \tot List \tot List$ & залепяне на списък
        в началото на списък \cendrow
      \end{tabular}
    \end{center}
  \end{frame}

  \begin{frame}[fragile]{Пример}
    Искаме да извадим всички училища, физически намиращи се в обекти,
    които се казват Sofia:
    \begin{lstwrap}\begin{lstlisting}
and
    (get (consString 'tagFilter'
            (consList (consString '='
                (consString 'amenity'
                    (consString 'school' empty)))
        empty)))
    (next (consString 'in' empty)
        (get (consString 'tagFilter' (consList
            (consString '='
                (consString 'name'
                    (consString 'Sofia' empty)))
        empty))))
    \end{lstlisting}\end{lstwrap}
  \end{frame}

  \begin{frame}[fragile]{``Стандартна'' библиотека}
    \begin{lstwrap}\begin{lstlisting}
      -- get all items of given type
      nodes     :=  get (consString 'all'
      (consString 'nodes' empty)).
      ways      :=  get (consString 'all'
      (consString 'ways' empty)).
      relations :=  get (consString 'all'
      (consString 'relations' empty)).
      areas     :=  get (consString 'all'
      (consString 'areas' empty)).

      -- get all items in the universe
      everything := get (consString 'all' empty).
    \end{lstlisting}\end{lstwrap}
  \end{frame}

  \begin{frame}[fragile]{``Стандартна'' библиотека}
    \begin{lstwrap}\begin{lstlisting}
-- find items by tag key and value infix
contains  :=  \k: String, n: String => get
    (consString 'tagFilter'
        (consList (consString '~'
            (consString k (consString n empty)))
        empty)).

-- find items within distance of given items
within    :=  \dist : Num => next
    (consString 'around' (consNum dist empty)) .

-- find items inside of given items
in        :=  next (consString 'in' empty).
    \end{lstlisting}\end{lstwrap}
  \end{frame}
  \begin{frame}[fragile]{``Стандартна'' библиотека}
    \begin{lstwrap}\begin{lstlisting}
-- find items by name
name      :=  \x => or (or
        (kv 'name' x)
        (kv 'int_name' x))
    (kv 'name:en' x).

-- find items by name infix
nameLike  :=  \x => or (or
        (contains 'name' x)
        (contains 'int_name' x))
    (contains 'name:en' x).

-- find items by amenity key (fountain, school...)
amenity   :=  kv 'amenity'.

-- find items by tag key and value
kv        :=  \k: String, n: String => get
    (consString 'tagFilter'
        (consList (consString '='
            (consString k (consString n empty)))
    empty)).
    \end{lstlisting}\end{lstwrap}
  \end{frame}
  \begin{frame}[fragile]{``Стандартна'' библиотека}
    \begin{lstwrap}\begin{lstlisting}
-- identity
id        := \y => y.

-- the set of all cities
city      := or (or
        (kv 'admin_level' '8')
        (kv 'admin_level' '6'))
    (kv 'capital' '4').

-- within 100 metres
near      :=  within 100.
    \end{lstlisting}\end{lstwrap}
  \end{frame}

  \begin{frame}[fragile]{Пример (отново)}
    Искаме да извадим всички училища, физически намиращи се в обекти,
    които се казват Sofia:
    \begin{lstwrap}\begin{lstlisting}
and (amenity 'school') (in (name 'Sofia'))
    \end{lstlisting}\end{lstwrap}
  \end{frame}

  \section{Подтипове}
  \begin{frame}{Подтипове}няколко слайда тук\end{frame}

  \section{Категорийни граматики (формално)}
  \begin{frame}{Категорийно затваряне}
    \begin{enumerate}
        \item \label{itm:atomic} $A \in \tau \implies A \in \cclos{\tau}$
        \item \label{itm:right}  $X, Y \in \cclos{\tau} \implies \lp X \rc Y \rp \in \cclos{\tau}$
        \item \label{itm:left}   $X, Y \in \cclos{\tau} \implies \lp X \lc Y \rp \in \cclos{\tau}$
    \end{enumerate}
  \end{frame}

  \begin{frame}{(Чиста) категорийна граматика}
    $ G = \langle \Sigma, N, S, f, n \rangle $ е \emph{категорийна граматика}, ако
    \begin{itemize}
        \item $ \Sigma $ е крайно множество от \emph{терминали}
        \item $ N $ е крайно множество от \emph{нетерминали} (атомарни категории)
        \item $ S \in N $
        \item $ f : \Sigma \fun \hat{N} $, където $\hat{N}$ е множеството от
            \textbf{крайни} подмножества на $\cclos{N}$
        \item $ n \in \mathbb{N} $
    \end{itemize}
  \end{frame}

  \begin{frame}{Правила за извод}
    \begin{itemize}
        \item Ако $ a \in \Sigma, X \in f(a) $, то \[ \lb X \rb \gderiv_G a \]
        \item Ако $ X \rc Y \in \cclos{N}, Y \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m \in \cclos{N}, 0 \leq m \leq n $
            то \[ \lb X \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m \rb \gderiv_G \lb X \rc Y \rb \lb Y \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m \rb \]
        \item Ако $ X \lc Y \in \cclos{N}, Y \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m \in \cclos{N}, 0 \leq m \leq n $
            то \[ \lb X \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m \rb \gderiv_G \lb Y \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m \rb \lb X \lc Y \rb \]
    \end{itemize}
  \end{frame}

  \begin{frame}{Пример}
    Ще построим проста граматика $G = \langle \Sigma, N, S, f, n \rangle$
    която генерира \code{cities in Germany}:

    \begin{align*}
        \Sigma \defeq& \{ cities, in, Germany \} \\
        N \defeq& \{ GSet \} \\
        S \defeq& GSet \\
        f(x) \defeq&
            \begin{cases*}
                \{ GSet \},& x = cities \\
                \{ GSet \},& x = Germany \\
                \{ GSet \lc GSet \rc GSet \},& x = in \\
            \end{cases*} \\
        n \defeq& 1 \\
    \end{align*}
  \end{frame}

  \begin{frame}{Примерен извод}
    \begin{center}
        \begin{tabular}{c}
            $\underline{\lb GSet \rb}$ \\ $\gstep$ \\
            $\lb GSet \rb \underline{\lb GSet \lc GSet \rb}$ \\ $\gstep$ \\
            $\underline{\lb GSet \rb} \lb GSet \lc GSet \rc GSet \rb \lb GSet \rb$ \\ $\gstep$ \\
            $cities \sq \underline{\lb GSet \lc GSet \rc GSet \rb} \lb GSet \rb$ \\ $\gstep$ \\
            $cities \sq in \sq \underline{\lb GSet \rb}$ \\ $\gstep$ \\
            $cities \sq in \sq Germany$ \\
        \end{tabular}
    \end{center}
  \end{frame}

  \begin{frame}{Свойство}
    Всяка КГ $G = \langle \Sigma, N, S, f, n \rangle$ е еквивалентна на
    (безкрайна) контекстно свободна граматика
    $G^C = \langle \Sigma, \lb \cclos{N} \rb, R, \lb S \rb \rangle$.

    Освен това, имайки извод $\mu: \alpha_1 \gstep ... \gstep \alpha_r$.
    Можем да построим специална \textbf{крайна} контекстно-свободна граматика
    $G_\mu^C = \langle \Sigma, \lb \catsin{\mu} \rb, \restr{R}{\lb \catsin{\mu} \rb}, \lb S \rb \rangle$,
    в която $\mu$ е валиден извод и всички нейни изводи са изводи и в $G$.

    \begin{proof}
        Дефинициите на $\gstep$ за $G$ и за $G^C$ съвпадат.
    \end{proof}
  \end{frame}

  \begin{frame}{CYK за КГ}
    По даден вход (дума) строим строим множество $P$ от тройки
    $(X, i, j)$, $X \in \cclos{N}, 1 \leq i \leq j \leq k$ индуктивно,
    опитвайки се да получим
    $(S, 1, k)$.

    \begin{enumerate}
    \label{cyk:rules}
        \item Ако $X \in f(w_i)$, то $(X, i, i) \in P$.
        \item Ако $(X \rc Y, i, p) \in P, (Y \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m, p + 1, j) \in P$,
            то $(X \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m, i, j) \in P$.
        \item Ако $(X \lc Y, p + 1, j) \in P, (Y \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m, i, p) \in P$,
            то $(X \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m, i, j) \in P$.
    \end{enumerate}
  \end{frame}

  \begin{frame}{Коректност}
    \begin{enumerate}
    \label{cyk:rules}
        \item Ако $X \in f(w_i)$, то $(X, i, i) \in P$.
        \item Ако $(X \rc Y, i, p) \in P, (Y \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m, p + 1, j) \in P$,
            то $(X \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m, i, j) \in P$.
        \item Ако $(X \lc Y, p + 1, j) \in P, (Y \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m, i, p) \in P$,
            то $(X \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m, i, j) \in P$.
    \end{enumerate}

    \begin{equation}\label{eq:left}
        (X, i, j) \in P \implies \lb X \rb \gsteps w_i ... w_j
    \end{equation}
  \end{frame}
  \begin{frame}{Пълнота}
    \begin{enumerate}
    \label{cyk:rules}
        \item Ако $X \in f(w_i)$, то $(X, i, i) \in P$.
        \item Ако $(X \rc Y, i, p) \in P, (Y \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m, p + 1, j) \in P$,
            то $(X \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m, i, j) \in P$.
        \item Ако $(X \lc Y, p + 1, j) \in P, (Y \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m, i, p) \in P$,
            то $(X \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m, i, j) \in P$.
    \end{enumerate}
    \begin{equation}\label{eq:right}
        \lb X \rb \gsteps w_i ... w_j \implies (X, i, j) \in P
    \end{equation}
  \end{frame}

  \section{Категорийни граматики върху Minipass}
  \begin{frame}{Категорийни граматики върху Minipass}няколко слайда тук\end{frame}

  \section{Превод от Minipass към Overpass}
  \begin{frame}{Превод}няколко слайда тук\end{frame}

  \section{Резултат}
  \begin{frame}{Резултат}няколко слайда тук\end{frame}

\end{document}
