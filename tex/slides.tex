\documentclass[9pt]{beamer}
\usepackage[english,bulgarian]{babel}
\input{./macros.tex}
\usetheme{metropolis}
% \usecolortheme{dove}
\title{Катег\'орийни граматики за геопространствени заявки}
\date{\today}
\author{Бла Бла}
\institute{Магистър университет ФМИ бла}
\begin{document}
  \maketitle

  \section{Геопространствени заявки}
  \begin{frame}[fragile]
    Вход:
    \begin{lstwrap}\begin{lstlisting}
      pharmacies near parking spaces in Berlin
    \end{lstlisting}\end{lstwrap}
    Изход:

    \includegraphics[width=0.32\textwidth]{map/world.png}
    \hfill
    \includegraphics[width=0.32\textwidth]{map/berlin.png}
    \hfill
    \includegraphics[width=0.32\textwidth]{map/pharmacy.png}
  \end{frame}

  \section{Overpass}
  \begin{frame}[fragile]{Overpass код}
    \begin{lstwrap}\begin{lstlisting}
    ( node["amenity" = "parking_space"]; ) -> .x1;
    ( area["name" = "Berlin"]; area["int_name" = "Berlin"]; area["name:en" = "Berlin"]; ) -> .x2;
    ( node(area.x2)(around.x1:100.0)["amenity" = "pharmacy"]; ) -> .x3;
    .x3 out;
    \end{lstlisting}\end{lstwrap}
  \end{frame}

  \begin{frame}{Типове обекти в Overpass}
    \begin{itemize}
      \item node
      \item way
      \item relation
      \item area
    \end{itemize}
  \end{frame}

  \begin{frame}{Set}

  \end{frame}

  \begin{frame}[fragile]{Резултат от заявка}
    \begin{lstwrap}\begin{lstlisting}
        out <input set>;
    \end{lstlisting}\end{lstwrap}
  \end{frame}

  \begin{frame}[fragile]{Извличане на обекти}
    \begin{itemize}
      \item Синтаксис
        \begin{lstwrap}\begin{lstlisting}
            <object keyword><filter><filter>...<filter>
        \end{lstlisting}\end{lstwrap}
      \item Пример
        \begin{lstwrap}\begin{lstlisting}
            node[name="Foo"];
            out;
        \end{lstlisting}\end{lstwrap}
        \begin{lstwrap}\begin{lstlisting}
            node[name="Foo"] -> ._;
            out ._;
        \end{lstlisting}\end{lstwrap}
    \end{itemize}
  \end{frame}

  \begin{frame}[fragile]{Извличане на обекти}
    \begin{itemize}
      \item Синтаксис
        \begin{lstwrap}\begin{lstlisting}
            <keyword><filter><filter>...<filter>
        \end{lstlisting}\end{lstwrap}
      \item Ключови думи
        \begin{center}
            \begin{tabular}{r|l}
                \code{node} & retrieves nodes \\
                \code{way} & retrieves ways \\
                \code{relation} & retrieves relations \\
                \code{area} & retrieves areas \\
                \code{nwr} & retrieves nodes, ways, and relations \\
            \end{tabular}
        \end{center}
    \end{itemize}
  \end{frame}

  \begin{frame}[fragile]{Други филтри за ``тагове''}
    \begin{lstwrap}\begin{lstlisting}
        node[amenity="cafe"];
    \end{lstlisting}\end{lstwrap}

    \begin{lstwrap}\begin{lstlisting}
        node[amenity="cafe"][name="Moondeers"];
    \end{lstlisting}\end{lstwrap}

    \begin{lstwrap}\begin{lstlisting}
        node[amenity="cafe"][name~"^moondeers$",i];
    \end{lstlisting}\end{lstwrap}

    \begin{lstwrap}\begin{lstlisting}
        area["administrative"];
    \end{lstlisting}\end{lstwrap}
  \end{frame}

  \begin{frame}[fragile]{Сечение}
      \begin{lstwrap}\begin{lstlisting}
          node[amenity="cafe"] -> .cafes;
          node.cafes;
      \end{lstlisting}\end{lstwrap}
      \begin{lstwrap}\begin{lstlisting}
          node[amenity="cafe"] -> .cafes;
          node.cafes[name="Moondeers"];
      \end{lstlisting}\end{lstwrap}
  \end{frame}

  \begin{frame}[fragile]{Обекти в area}
    \begin{lstwrap}\begin{lstlisting}
      area[name="Frankfurt"] -> fr;
      node(area.fr);
      out;
    \end{lstlisting}\end{lstwrap}
  \end{frame}

  \begin{frame}[fragile]{Обекти на разстояние от други обекти}
    \begin{lstwrap}\begin{lstlisting}
        node[amenity="parking_space"] -> pspaces;
        node[amenity="cafe"](around.pspaces:120) -> x;
        out x;
    \end{lstlisting}\end{lstwrap}
    \begin{lstwrap}\begin{lstlisting}
        area[name="Bonn"];
        node(area)[highway=bus_stop];
        node(around:100)[amenity=cinema];
        out;
    \end{lstlisting}\end{lstwrap}
  \end{frame}

  \begin{frame}[fragile]{Обединение}
    \begin{lstwrap}\begin{lstlisting}
        node[amenity="cafe"] -> .cafes;
        area[name="Bonn"] -> .bonn;
        area[name="Frankfurt"] -> .frankfurt;
        node.cafes(area.bonn) -> .cb;
        node.cafes(area.frankfurt) -> .cf;
        (.cf; .cb;) -> .cfb;
        out .cfb;
    \end{lstlisting}\end{lstwrap}

    \begin{lstwrap}\begin{lstlisting}
        area[name="Bonn"] -> .bonn;
        area[name="Frankfurt"] -> .frankfurt;
        ( node[amenity="cafe"](area.bonn); node[amenity="cafe"](area.frankfurt); );
        out;
    \end{lstlisting}\end{lstwrap}
  \end{frame}

  \section{Типово $\lambda$-смятане}
  \begin{frame}{Типове}
    \begin{itemize}
      \item $\tsymbs \defeq \{ t', t'', t''' ... \}$ за $T \subseteq \tsymbs$ - изброимо множество от \emph{типови символи}
      \item $\tclos{T} \subseteq (T \, \cup \,\{\, \tot, ), ( \,\})^*$ - \emph{типово затваряне},
        дефинирано индуктивно:
          \begin{itemize}
              \item $\sigma \in T \implies \sigma \in \tclos{T}$
              \item $\sigma, \tau \in \tclos{T} \implies (\sigma \tot \tau) \in \tclos{T}$
          \end{itemize}
      \item Конвенция: дясна асоциативност на $\tot$
      \item Типизираща функция:
        \[ \typeoff : X \fun \tclos{T} \]
      \item Прилагане на изображение върху сложен тип:
        \begin{equation*}
            \hat{\varphi}(\sigma) =
            \begin{cases*}
                \varphi(\sigma) ,& $\sigma \in X$ \\
                \hat{\varphi}(\sigma') \tot \hat{\varphi}(\sigma'') ,&
                    $\sigma = \sigma' \tot \sigma'' \in \tclos{X}$ \\
            \end{cases*}
        \end{equation*}
    \end{itemize}
  \end{frame}
  \begin{frame}{Термове}
    Нека $C \subset \const$ са константи с типове от $T$.

    $\plambda{T}{C}$ се дефинира индуктивно:
    \begin{itemize}
        \item Константа:  \[ c \in C \implies c \in \plambda{T}{C} \]
        \item Променлива: \[ v \in \lvars \implies v \in \plambda{T}{C} \]
        \item Прилагане:  \[ A, B \in \plambda{T}{C} \implies (AB) \in \plambda{T}{C} \]
        \item Абстракция: \[ v \in \lvars, A \in \plambda{T}{C}, \sigma \in \tclos{T}
                \implies (\lambda v : \sigma \abstr A) \in \plambda{T}{C} \]
    \end{itemize}
  \end{frame}

  \begin{frame}{Контекст}
    \begin{itemize}
      \item Ако $M \in \plambda{T}{C}, \sigma \in \tclos{T}$, то $M : \sigma$ се нарича
          \emph{statement}. $M$ се нарича \emph{субект} and $\sigma$
          се нарича \emph{тип}.
      \item Statement с променлива за субект се нарича \emph{декларация}.
      \item Множество декларации с различни субекти се нарича \emph{контекст}.
      \item \emph{Извод} от контекст има вида $\Gamma \vdash M: \sigma$, където
          $\Gamma$ е контекст, а $M: \sigma$ е statement.
    \end{itemize}
  \end{frame}

  \begin{frame}{Типизиране на термове}
    \begin{itemize}
        \item Константи
            \cenderiv{
                \hypo{c \in C}
                \infer1{\Gamma \vdash c : \typeof{c}}
            }
        \item Променливи
            \cenderiv{
                \hypo{x : \sigma \in \Gamma}
                \infer1{\Gamma \vdash x : \sigma}
            }
        \item Прилагания
            \cenderiv{
                \hypo{\Gamma \vdash A : \sigma' \tot \sigma''}
                \hypo{\Gamma \vdash B : \sigma'}
                \infer2{\Gamma \vdash (AB) : \sigma''}
            }
        \item Абстракции
            \cenderiv{
                \hypo{\Gamma \circ x : \tau \vdash A : \sigma}
                \infer1{\Gamma \vdash (\lambda x : \tau \abstr A) : \tau \tot \sigma}
            }
    \end{itemize}
  \end{frame}

  \section{Minipass: междинен език}
  \begin{frame}{Графова абстракция}
    \begin{itemize}
      \item Върхове: Overpass обекти
        \begin{itemize}
          \item по тип
          \item по стойност на таг (например име)
          \item ...
        \end{itemize}
      \item Ребра: връзки между обектите \pika
        \begin{itemize}
          \item близост
          \item физическо съдържане
          \item ...
        \end{itemize}
    \end{itemize}
  \end{frame}

  \begin{frame}[fragile]{Графова абстракция: пример}
    Заявка:
    \begin{lstwrap}\begin{lstlisting}
      bus stops near schools in Russia
    \end{lstlisting}\end{lstwrap}

    \begin{enumerate}
      \item Нека $B$ е множеството от върховете, имащи етикет
        ``е автобусна спирка''
      \item Нека $S$ е множеството от върховете, имащи етикет
        ``е училище''
      \item Нека $R$ е множеството от върховете, имащи етикет
        ``английското му име е \emph{Russia}''
      \item Нека $N$ е множеството от върховете, които можем да
        достигнем от върхове в $S$, ходейки по ребро, имащо етикет
        ``е близо до''
      \item Нека $P$ е множеството от върховете, които можем да
        достигнем от върхове в $R$, ходейки по ребро, имащо етикет
        ``е във вътрешността на''
      \item Резултатът е $B \cap N \cap P$.
    \end{enumerate}
  \end{frame}

  \begin{frame}{Синтаксис: Основни типове}
    \begin{itemize}
      \item $Num$ - цяло число \pika
      \item $String$ - низ \pika
      \item $List$ - полиморфен свързан списък, който може
        да съдържа $Num$, $String$ и $List$
      \item $GSet$ - множество от географски обекти: съответства на \code{Set}
        в Overpass
    \end{itemize}
  \end{frame}

  \begin{frame}{Синтаксис: $\lambda$}
    \begin{itemize}
      \item Прилагане на термове (ляво-асоциативно)
        \begin{center}
          \code{<term1> <term2>}
        \end{center}
      \item Абстракция
        \begin{center}
          \code{lambda <varname> : <type> => <term>}
        \end{center}
      \item Променливи и константи
      \item Сложни типове
        \begin{center}
          \code{<type1> -> <type2>}
        \end{center}
    \end{itemize}
  \end{frame}

  \begin{frame}{Синтаксис: ключови думи}
    \begin{center}
      \begin{tabular}{r l p{0.35\textwidth}}
        Идентификатор  & Тип & \\
        \hline
        \code{and}  & $GSet \tot GSet \tot GSet$ & сечение \cendrow
        \code{or}   & $GSet \tot GSet \tot GSet$ & обединение \cendrow
        \code{not}  & $GSet \tot GSet$ & допълнение \cendrow
        \hline
        \code{get}  & $List \tot GSet$ & извличане на географски обекти по
        етикет на връх \cendrow
        \code{next} & $List \tot GSet \tot GSet$ & извличане на географски обекти
        траверсирайки ребро \cendrow
      \end{tabular}
    \end{center}
  \end{frame}
  \begin{frame}{Синтаксис: ключови думи за списъци}
    \begin{center}
      \begin{tabular}{r l p{0.35\textwidth}}
        Идентификатор  & Тип & \\
        \hline
        \code{empty} & $List$ & празен списък \cendrow
        \code{consNum} & $Num \tot List \tot List$ & залепяне на число
        в началото на списък \cendrow
        \code{consString} & $String \tot List \tot List$ & залепяне на низ
        в началото на списък \cendrow
        \code{consList} & $List \tot List \tot List$ & залепяне на списък
        в началото на списък \cendrow
      \end{tabular}
    \end{center}
  \end{frame}

  \begin{frame}[fragile]{Пример}
    Искаме да извадим всички училища, физически намиращи се в обекти,
    които се казват Sofia:
    \begin{lstwrap}\begin{lstlisting}
and
    (get (consString 'tagFilter'
            (consList (consString '='
                (consString 'amenity'
                    (consString 'school' empty)))
        empty)))
    (next (consString 'in' empty)
        (get (consString 'tagFilter' (consList
            (consString '='
                (consString 'name'
                    (consString 'Sofia' empty)))
        empty))))
    \end{lstlisting}\end{lstwrap}
  \end{frame}

  \begin{frame}[fragile]{``Стандартна'' библиотека}
    \begin{lstwrap}\begin{lstlisting}
      -- get all items of given type
      nodes     :=  get (consString 'all'
      (consString 'nodes' empty)).
      ways      :=  get (consString 'all'
      (consString 'ways' empty)).
      relations :=  get (consString 'all'
      (consString 'relations' empty)).
      areas     :=  get (consString 'all'
      (consString 'areas' empty)).

      -- get all items in the universe
      everything := get (consString 'all' empty).
    \end{lstlisting}\end{lstwrap}
  \end{frame}

  \begin{frame}[fragile]{``Стандартна'' библиотека}
    \begin{lstwrap}\begin{lstlisting}
-- find items by tag key and value infix
contains  :=  \k: String, n: String => get
    (consString 'tagFilter'
        (consList (consString '~'
            (consString k (consString n empty)))
        empty)).

-- find items within distance of given items
within    :=  \dist : Num => next
    (consString 'around' (consNum dist empty)) .

-- find items inside of given items
in        :=  next (consString 'in' empty).
    \end{lstlisting}\end{lstwrap}
  \end{frame}
  \begin{frame}[fragile]{``Стандартна'' библиотека}
    \begin{lstwrap}\begin{lstlisting}
-- find items by name
name      :=  \x => or (or
        (kv 'name' x)
        (kv 'int_name' x))
    (kv 'name:en' x).

-- find items by name infix
nameLike  :=  \x => or (or
        (contains 'name' x)
        (contains 'int_name' x))
    (contains 'name:en' x).

-- find items by amenity key (fountain, school...)
amenity   :=  kv 'amenity'.

-- find items by tag key and value
kv        :=  \k: String, n: String => get
    (consString 'tagFilter'
        (consList (consString '='
            (consString k (consString n empty)))
    empty)).
    \end{lstlisting}\end{lstwrap}
  \end{frame}
  \begin{frame}[fragile]{``Стандартна'' библиотека}
    \begin{lstwrap}\begin{lstlisting}
-- identity
id        := \y => y.

-- the set of all cities
city      := or (or
        (kv 'admin_level' '8')
        (kv 'admin_level' '6'))
    (kv 'capital' '4').

-- within 100 metres
near      :=  within 100.
    \end{lstlisting}\end{lstwrap}
  \end{frame}

  \begin{frame}[fragile]{Пример (отново)}
    Искаме да извадим всички училища, физически намиращи се в обекти,
    които се казват Sofia:
    \begin{lstwrap}\begin{lstlisting}
and (amenity 'school') (in (name 'Sofia'))
    \end{lstlisting}\end{lstwrap}
  \end{frame}


  \section{Подтипове}
  \begin{frame}{Подтипове}
    \begin{align*}
        Capital & \less City \less GSet \\
        Name & \less String \\
        Distance & \less Number \\
    \end{align*}
  \end{frame}

  \begin{frame}{Meet and Join}
    \begin{itemize}
      \item Meet:
      \begin{equation}
          z \less x, z \less y,
              \forall t \in X (t \less x, t \less y \implies t \less z)
      \end{equation}

      \item Join:
      \begin{equation}
          x \less z, y \less z,
              \forall t \in X (x \less t, y \less t \implies z \less t)
      \end{equation}

    \item Частична решетка: за всеки два елемента има по не повече от един
      meet и join. Отбелязваме ги с частичните оператори $x \meet y$
      и $x \join y$.
    \end{itemize}
  \end{frame}

  \begin{frame}
    $\tsymbs$ - изброимо множество от типови символи

    Типова решетка: частична решетка с носител, който е подмножество на $\tsymbs$.
  \end{frame}

  \begin{frame}{Подтипова релация върху сложни типове}
    \begin{itemize}
        \item $(\sigma \tot \sigma') \less (\tau \tot \tau') \iff (\sigma' \less \sigma)
            \& (\tau \less \tau')$
        \item Контравариантност!
    \end{itemize}
  \end{frame}

  \begin{frame}{$\lambda$-термове с подтипове}
    Нека $C \subset \const$ е множество от константи, имащи типове от $T$.

    Дефинираме $\fancylambda{T}{C}$ индуктивно:
    \begin{itemize}
        \item Константа:   \[ c \in C \implies c \in \fancylambda{T}{C} \]
        \item Променлива:  \[ v \in \lvars \implies v \in \fancylambda{T}{C} \]
        \item Прилагане:   \[ A, B \in \fancylambda{T}{C} \implies (AB) \in \fancylambda{T}{C} \]
        \item Абстракция:  \[ v \in \lvars, A \in \fancylambda{T}{C}, \sigma \in \tclos{T}
                \implies (\lambda v : \sigma \abstr A) \in \fancylambda{T}{C} \]
        \item Конструиране: \[ \sigma \in T, A \in \fancylambda{T}{C}
                \implies \sigma[A] \in \fancylambda{T}{C} \]
    \end{itemize}
  \end{frame}
  \begin{frame}{Типизиране на $\lambda$-смятане с подтипове}
    \begin{itemize}
        \item Константи
            \cenderiv{
                \hypo{c \in C}
                \infer1{\Gamma \vdash c : \typeof{c}}
            }
        \item Променливи
            \cenderiv{
                \hypo{x : \sigma \in \Gamma}
                \infer1{\Gamma \vdash x : \sigma}
            }
        \item Приложения
            \cenderiv{
                \hypo{\Gamma \vdash A : \sigma' \tot \sigma''}
                \hypo{\Gamma \vdash B : \tau}
                \hypo{\tau \less \sigma'}
                \infer3{\Gamma \vdash (AB) : \sigma''}
            }
        \item Абстракции
            \cenderiv{
                \hypo{\Gamma \circ x : \tau \vdash A : \sigma}
                \infer1{\Gamma \vdash (\lambda x : \tau \abstr A) : \tau \tot \sigma}
            }
        \item Upcast
            \cenderiv{
                \hypo{\Gamma \vdash A : \sigma}
                \hypo{\sigma \less \tau}
                \infer2{\Gamma \vdash \tau[A] : \tau}
            }
        \item Downcast
            \cenderiv{
                \hypo{\Gamma \vdash A : \sigma}
                \hypo{\tau \less \sigma}
                \infer2{\Gamma \vdash \tau[A] : \tau}
            }
    \end{itemize}
  \end{frame}

  \section{Включване на типови решетки}

  \begin{frame}{Включване на типови решетки}
    Ако $\lattice{ T}{ \less' }$ и $\lattice{ S}{ \less }$
    са типови решетки, казваме, че
    $\lattice{ T}{ \less' } \tless \lattice{ S}{ \less }$ ако:
    \begin{itemize}
        \item $S \subseteq T$
        \item $\less \subseteq \less'$ и $\restr{\less'}{S \times S} = \less$
        \item $\forall \tau \in (T \setminus S) ((\exists \sigma \in S : \tau \less \sigma )
            \xor (\exists \sigma \in S : \sigma \less \tau)$
    \end{itemize}
  \end{frame}

  \begin{frame}{Смачкваща функция}
    $\squash: T \fun S$ е смачкваща функция за
    $\lattice{ T}{ \less' } \tless \lattice{ S}{ \less }$, ако:
    \begin{itemize}
        \item за всяко $\tau \in S$, $\squash(\tau) = \tau$
        \item следва дадената релация:
            \[ \forall \sigma \in T
                (\squash(\sigma) \less' \sigma \lor \sigma \less' \squash(\sigma)) \]
        \item запазва дадената релация:
            \[ \forall \sigma, \tau \in T (\sigma \less' \tau \implies
                \squash(\sigma) \less \squash(\tau)) \]
    \end{itemize}
  \end{frame}

  \begin{frame}{Свойства на смачкващата функция}
    \begin{itemize}
      \item Ако $\sigma$ е над малката релация, то $\squash(\sigma)$ е максимален
        елемент в нея, такъв че $\squash(\sigma) \less \sigma$
      \item Ако $\sigma$ е под малката релация, то $\squash(\sigma)$ е минимален
        елемент в нея, такъв че $\sigma \less \squash(\sigma)$
      \item Уникална е
    \end{itemize}
  \end{frame}

  \begin{frame}{Смачкваща функция върху $\lambda$-термове}
    Ако $\squash: T \fun S$ е смачкваща функция за $T \tless S$ и
    константите $C$ имат типове от $S$,
    $\lsquash: \fancylambda{T}{C} \fun \fancylambda{S}{C}$
    се дефинира индуктивно:

    \[
        \lsquash(A) =
        \begin{cases*}
            c ,& $A = c \in C$, \\
            v ,& $A = v \in \lvars$, \\
            \lsquash(M) \lsquash(N) ,& $A = (MN)$, \\
            \lambda x : \tsquash(\sigma) \abstr \lsquash(M)
 ,& $A = \lambda x : \sigma \abstr M$, \\
                \tsquash(\sigma)[M] ,& $A = \sigma[M]$. \\
        \end{cases*}
    \]

    Тривиално можем да смачкваме и контексти:
    \[
        \consquash(\Gamma)
            = \{ x : \tsquash(\sigma) \mid (x : \sigma) \in \Gamma \}
    \]

    \textbf{Свойство}:
    \[ \Gamma \vdash A : \sigma \implies
        \consquash(\Gamma) \vdash \lsquash(A) : \tsquash(\sigma) \]
  \end{frame}

  \section{Библиотеки от подтипове}
  \newcommand\clonesub{\subtyper{clone}_{\subtyper{\xi} \suptyper{\xi}}}
  \newcommand\clonesup{\suptyper{clone}_{\subtyper{\xi} \suptyper{\xi}}}

  \begin{frame}{Клониране на тип}
    Искаме да клонираме тип $\tau$.

    Нека $\subtyper{\xi}, \suptyper{\xi}$ са изображения от надмножество на
    $\ts{\tau}$ в непресичащи се подмножества на $\tsymbs$.

    Дефинираме
    $\suptyper{clone}_{\subtyper{\xi} \suptyper{\xi}}$ и
    $\subtyper{clone}_{\subtyper{\xi} \suptyper{\xi}}$ с взаимна индукция:
    \[
        \subtyper{clone}_{\subtyper{\xi} \suptyper{\xi}}(\tau) =
        \begin{cases*}
            \subtyper{\xi}(\tau) ,&
                $\tau \in T$ \\
            \suptyper{clone}_{\subtyper{\xi} \suptyper{\xi}}(\tau_1)
                \tot \subtyper{clone}_{\subtyper{\xi} \suptyper{\xi}}(\tau_2) ,&
                $\tau = \tau_1 \tot \tau_2$ \\
        \end{cases*}
    \]

    \[
        \suptyper{clone}_{\subtyper{\xi} \suptyper{\xi}}(\tau) =
        \begin{cases*}
            \suptyper{\xi}(\tau) ,&
                $\tau \in T$ \\
            \subtyper{clone}_{\subtyper{\xi} \suptyper{\xi}}(\tau_1)
                \tot \suptyper{clone}_{\subtyper{\xi} \suptyper{\xi}}(\tau_2) ,&
                $\tau = \tau_1 \tot \tau_2$ \\
        \end{cases*}
    \]
  \end{frame}

  \begin{frame}{Добавяне на подтип към решетка}
    Нека имаме:
    \begin{itemize}
        \item типова решетка $\lattice{ T}{ \less }$
        \item типов символ $\sigma \in \tsymbs \setminus T$
        \item изображение $\varphi : T \fun \tclos{T}$
        \item тип $\tau$ такъв че $\hat{\varphi}(\tau)$ е дефинирано
    \end{itemize}
    Взимаме $\suptyper{\xi}$ и $\subtyper{\xi}$ - инекции от
    $\ts{\hat{\varphi}(\tau)}$ в $\tsymbs \setminus (T \cup \{ \sigma \})$ такива че
    $range(\suptyper{\xi}) \cap range(\subtyper{\xi}) = \emptyset$

    Сега дефинираме $\tadd$:
        \[ \langle \lattice{ T}{ \less }, \varphi \rangle
            \tadd (\sigma \lass \tau)
            \defeq
            \langle \lattice{ T'}{ \less' }, \varphi' \rangle
        \] където:
    \begin{itemize}
        \item $\rho = \clonesub(\hat{\varphi}(\tau))$
        \item $T' = T \cup ((range(\subtyper{\xi}) \cup range(\suptyper{\xi})) \cap \ts{\rho})$
        \item $\less'$ е транзитивното и рефлексивно затваряне на
            $\less \cup \{ (\sigma', \tau') \in T' \times T \mid \subtyper{\xi}(\tau') = \sigma' \}
                   \cup \{ (\sigma', \tau') \in T \times T' \mid \suptyper{\xi}(\sigma') = \tau' \}$
        \item $\varphi' = \varphi \cup \{ (\sigma, \rho) \}$
    \end{itemize}
  \end{frame}

  \begin{frame}{Библиотека от подтипове}
    $\Theta_T = \theta_1 ... \theta_n$ се нарича \emph{библиотека от подтипове} над $T$
    ако конструкцията $\hat{\Theta}_T \defeq \langle \lattice{ T}{ \less }, \identity_T \rangle \oplus \theta_1 \oplus \theta_2 ... \oplus \theta_n$
    е дефинирана.

    \textbf{Свойства:}
    \begin{itemize}
        \item $\sigma \less \tau \implies \sigma \less' \tau$
        \item $\sigma \lass \tau \in \Theta \implies \varphi(\sigma) \less' \hat{\varphi}(\tau)$
    \end{itemize}
  \end{frame}

  \section{Превод от Minipass към Overpass}
  \begin{frame}{Трансформации}
    \includegraphics[width=\textwidth]{optimisation.eps}
  \end{frame}

  \begin{frame}{Тагнати термове}
    \begin{itemize}
        \item Константа:
            \[ c \in C, \tau \in \tclos{T} \implies \ttt{c}{\tau} \in \ttlambda{T}{C} \]
        \item Променлива:
            \[ v \in \lvars, \tau \in \tclos{T} \implies \ttt{v}{\tau} \in \ttlambda{T}{C} \]
        \item Приложение:
            \[ A, B \in \ttlambda{T}{C}, \tau \in \tclos{T} \implies \ttt{(AB)}{\tau} \in \ttlambda{T}{C} \]
        \item Абстракция:
            \[ v \in \lvars, A \in \ttlambda{T}{C},
                \tau = (\tau' \tot \tau'') \in \tclos{T},
                \implies \ttt{(\lambda v \abstr A)}{\tau} \in \ttlambda{T}{C} \]
    \end{itemize}
  \end{frame}
  \begin{frame}{Тагнати термове}
      \[
      \mcf{tag}_{\Gamma}(A) =
      \begin{cases*}
          \ttt{c}{\typeof{C}} ,& $A = c \in C$, \\
          \ttt{v}{\tau} ,& $A = v \in \lvars, \Gamma \vdash v : \tau$, \\
          \ttt{(\mcf{tag}_{\Gamma}(M) \app \mcf{tag}_{\Gamma}(N))}{\tau}
,& $A = (MN), \Gamma \vdash A : \tau$, \\
          \ttt{\lambda v \abstr \mcf{tag}_{\Gamma'}(M)}{\sigma \tot \tau}
,& $A = (\lambda v: \sigma \abstr M)
                , \Gamma' \vdash M : \tau
                , \Gamma' = \Gamma \circ v : \sigma$,\\
          \ttt{M}{\tau} ,& $A = \tau[M]$. \\
      \end{cases*}
    \]
  \end{frame}
  \begin{frame}{Тагнати термове}
    \[
        \mcf{untag'}_{\Gamma}(\ttt{A}{\tau}) =
        \begin{cases*}
            c ,& $A = c \in C$, \\
            v ,& $A = v \in \lvars$, \\
            \mcf{untag}_{\Gamma}(P) \app \mcf{untag}_{\Gamma}(Q)
 ,& $A = (PQ)$, \\
            \lambda v : \tau' \abstr \mcf{untag}_{\Gamma'}(P)
 ,& $A = (\lambda v \abstr P), \tau = (\tau' \tot \tau'')
                 , \Gamma' = \Gamma \circ v : \tau'$. \\
        \end{cases*}
    \]

    \[
        \mcf{untag}_{\Gamma}(\ttt{A}{\tau}) =
        \begin{cases*}
            M ,& $M = \mcf{untag'}_{\Gamma}(\ttt{A}{\tau}), \Gamma \vdash M : \tau$, \\
            \tau[M] ,& $M = \mcf{untag'}_{\Gamma}(\ttt{A}{\tau}), \Gamma \not\vdash M : \tau
            \text{ and } \tau[M] \text { is a valid cast}
            $, \\
            \neg ! ,& \text{otherwise}.
        \end{cases*}
    \]
  \end{frame}

  \begin{frame}{Пропагиране на типове}
    \[
        \mcf{up}_{\unify}(\ttt{A}{\tau}) =
        \begin{cases*}
            (\ttt{c}{\tau}, \{ \}) ,& $A = c \in C$ \\
            (\ttt{v}{\tau}, \{ v : \tau \}) ,& $A = v \in \lvars$ \\
            (\ttt{\lambda x \abstr \ttt{M}{\sigma'}}{(\eta' \tot \sigma') \unify \tau}, \Gamma')
 ,& $A = (\lambda x \abstr P)
                , \tau = (\eta \tot \sigma),$ \\
                \phantom{} &\phantom{, }$(\ttt{M}{\sigma'}, \Gamma) = \mcf{up}_{\unify}(P)
                , \Gamma' = \Gamma \setminus (x : \eta'),$ \\
                \phantom{} &\phantom{, }$(x : \eta') \in \Gamma$ \\
            (\ttt{\lambda x \abstr \ttt{M}{\sigma'}}{(\eta \tot \sigma') \unify \tau}, \Gamma')
 ,& $A = (\lambda x \abstr P)
                , \tau = (\eta \tot \sigma),$ \\
                \phantom{} &\phantom{, }$(\ttt{M}{\sigma'}, \Gamma) = \mcf{up}_{\unify}(P)$ \\
                \phantom{} &\phantom{, }$(x : \cdot) \not\in \Gamma$ \\
            (\ttt{P' Q'}{\sigma'' \unify \tau}, \Gamma_P \unify \Gamma_Q)
 ,& $A = (PQ), (P', \Gamma_P) = \mcf{up}_{\unify}(P),$ \\
                \phantom{} &\phantom{, }$(Q', \Gamma_Q) = \mcf{up}_{\unify}(Q), P' = \ttt{M}{\sigma' \tot \sigma''}$ \\
        \end{cases*}
    \]
  \end{frame}
  \begin{frame}{Пропагиране на типове}
    \[
        \mcf{down}_{\unify}(\ttt{A}{\tau}, \tau', \Gamma) =
        \begin{cases*}
            \ttt{c}{\tau \unify \tau'} ,& $A = c \in C$ \\
            \ttt{v}{\tau \unify \tau' \unify \tau''}
 ,& $A = v \in \lvars, (v : \tau'') \in \Gamma$ \\
            \ttt{\lambda x \abstr P'}{\tau''}
 ,& $A = (\lambda x \abstr P), \tau'' = \tau \unify \tau'$ \\
                \phantom{} &\phantom{, } $\tau'' = (\sigma \tot \eta), P' = \mcf{down}_{\unify}(P, \eta, \Gamma \circ (x : \sigma)),$ \\
            \ttt{P' Q'}{\tau''}
 ,& $A = (PQ), P = \ttt{M}{\sigma \tot \eta}, Q = \ttt{N}{\sigma'},$ \\
                \phantom{} &\phantom{, }$\tau'' = (\tau' \unify \tau), \sigma'' = (\sigma' \unify \sigma)$ \\
                \phantom{} &\phantom{, }$P' = \mcf{down}_{\unify}(P, (\sigma' \tot \tau''), \Gamma),
                Q' = \mcf{down}_{\unify}(Q, \sigma'', \Gamma)$ \\
        \end{cases*}
    \]
  \end{frame}

  \begin{frame}{Пропагиране на типове}
    \[
        \mcf{propagate}_{\unify}(P) = \mcf{down}_{\unify}(\ttt{M}{\tau}, \tau, \Gamma)
        \text{ , where } \mcf{up}_{\unify}(P) = (\ttt{M}{\tau}, \Gamma).
    \]
  \end{frame}

  \begin{frame}{Извод на типове}
    \[
        \sigma \unify \tau =
        \begin{cases*}
            \tau ,& $\sigma = \text{\code{*}}$, \\
            \sigma ,& $\tau = \text{\code{*}}$, \\
            \sigma ,& $\sigma = \tau$, \\
            (\sigma' \unify \tau') \tot (\sigma'' \unify \tau''), &
                $\sigma = (\sigma' \tot \sigma''), \tau = (\tau' \tot \tau'')$, \\
            \lnot ! ,& $\mathsf{otherwise}$. \\
        \end{cases*}
    \]
  \end{frame}

  \begin{frame}{Оптимизация на заявки}
    \includegraphics[width=\textwidth]{lattice.eps}
  \end{frame}

  \begin{frame}{Оптимизация на заявки}
\begin{center}
\begin{tabular}{|p{0.45\textwidth}|p{0.45\textwidth}|}
    \hline
    Subterm & Action \\
    \hline
    ``and'' of type $GSet[X] \tot GSet[Y] \tot GSet[Z]$
        & set its type to $GSet[X \cap Y \cap Z] \tot GSet[X \cap Y \cap Z] \tot GSet[X \cap Y \cap Z]$ \\
    \hline
    ``or'' of type $GSet[X] \tot GSet[Y] \tot GSet[Z]$
        & set its type to $GSet[X \cap Z] \tot GSet[Y \cap Z] \tot GSet[(X \cup Y) \cap Z]$ \\
    \hline
    $\beta$-redex & reduce it \\
    \hline
    ``get all nodes'' & change it to ``get everything'' of type $GSet[n]$ \\
    ``get all ways'' & change it to ``get everything'' of type $GSet[w]$ \\
    ``get all relations'' & change it to ``get everything'' of type $GSet[r]$ \\
    ``get all areas'' & change it to ``get everything'' of type $GSet[a]$ \\
    \hline
    ``next'' of type $GSet[X] \tot GSet[Y]$ applied to an ``in'' label
        & set its type to $GSet[X \cap \{ a \}] \tot GSet[Y \cap \{ n, w, r \}]$ \\
    \hline
    ``or'' with one of the arguments being of type $GSet[]$
        & rewrite the term to only the other argument \\
    \hline
    ... & ... \\
    \hline
\end{tabular}
\end{center}
  \end{frame}

  \begin{frame}{Оптимизация на заявки}
\[
    \sigma \unify \tau \defeq
    \begin{cases*}
        GSet[X \cap Y] ,& $\sigma = GSet[X], \tau = GSet[Y]$, \\
        Num ,& $\sigma = Num, \tau = Num$, \\
        String ,& $\sigma = String, \tau = String$, \\
        List ,& $\sigma = List, \tau = List$, \\
        (\sigma' \unify \tau') \tot (\sigma'' \unify \tau''), &
        $\sigma = (\sigma' \tot \sigma''), \tau = (\tau' \tot \tau'')$, \\
        \lnot ! ,& $\mathsf{otherwise}$. \\
    \end{cases*}
\]
  \end{frame}

  \begin{frame}{Превод}
    Резултатът от превеждане на Minipass терм до Overpass е \emph{стойност}
    и евентуално страничен ефект, който се изразява в извеждане на Overpass
    statement.

    \begin{itemize}
      \item Представяне на терма като функция, приложена върху аргументи
      \item Рекурсивно превеждане на всички аргументи
      \item Прилагане на правила за превод върху получената форма
    \end{itemize}
  \end{frame}
  \section{Категорийни граматики}
  \begin{frame}{Категорийни граматики: пример}
    \code{pharmacies near parking spaces in Berlin}
  \end{frame}

  \begin{frame}{Категорийни граматики: пример}
    \gramshort{
        \gramrow{pharmacies}{ GSet }{}
        \gramrow{Berlin}{ GSet }{}
    }
  \end{frame}
  \begin{frame}{Категорийни граматики: пример}
    \gramshort{
        \gramrow{pharmacies}{ GSet }{}
        \gramrow{Berlin}{ GSet }{}
        \gramrow{parking}{ GSet \rc Spaces }{}
        \gramrow{spaces}{Spaces}{}
    }
  \end{frame}
  \begin{frame}{Категорийни граматики: пример}
    \gramshort{
        \gramrow{pharmacies}{ GSet }{}
        \gramrow{Berlin}{ GSet }{}
        \gramrow{parking}{ GSet \rc Spaces }{}
        \gramrow{spaces}{Spaces}{}
        \gramrow{in}{ (GSet \lc GSet) \rc GSet }{}
        \gramrow{near}{ (GSet \lc GSet) \rc GSet }{}
    }
  \end{frame}
  \begin{frame}{Категорийни граматики: пример}
    \autoscaledtree{.{$GSet$}
        [ .{$GSet$}
            [ .{$GSet$} [ .{$pharmacies$} ] ]
            \edge[very thick];
            [ .{$GSet \lc GSet$}
                \edge[very thick];
                [ .{$(GSet \lc GSet) \rc GSet$} [ .{$near$} ] ]
                [ .{$GSet$}
                    \edge[very thick];
                    [ .{$GSet \rc Spaces$} [ .{$parking$} ] ]
                    [ .{$Spaces$} [ .{$spaces$} ] ]
                ]
            ]
        ]
        \edge[very thick];
        [ .{$GSet \lc GSet$}
            \edge[very thick];
            [ .{$(GSet \lc GSet) \rc GSet$} [ .{$in$} ] ]
            [ .{$GSet$} [ .{$Berlin$} ] ]
        ]
    }
  \end{frame}

  \section{Категорийни граматики (формално)}
  \begin{frame}{Категорийно затваряне}
    \begin{enumerate}
        \item \label{itm:atomic} $A \in \tau \implies A \in \cclos{\tau}$
        \item \label{itm:right}  $X, Y \in \cclos{\tau} \implies \lp X \rc Y \rp \in \cclos{\tau}$
        \item \label{itm:left}   $X, Y \in \cclos{\tau} \implies \lp X \lc Y \rp \in \cclos{\tau}$
    \end{enumerate}
  \end{frame}

  \begin{frame}{(Чиста) категорийна граматика}
    $ G = \langle \Sigma, N, S, f, n \rangle $ е \emph{категорийна граматика}, ако
    \begin{itemize}
        \item $ \Sigma $ е крайно множество от \emph{терминали}
        \item $ N $ е крайно множество от \emph{нетерминали} (атомарни категории)
        \item $ S \in N $
        \item $ f : \Sigma \fun \hat{N} $, където $\hat{N}$ е множеството от
            \textbf{крайни} подмножества на $\cclos{N}$
        \item $ n \in \mathbb{N} $
    \end{itemize}
  \end{frame}

  \begin{frame}{Правила за извод}
    \begin{itemize}
        \item Ако $ a \in \Sigma, X \in f(a) $, то \[ \lb X \rb \gderiv_G a \]
        \item Ако $ X \rc Y \in \cclos{N}, Y \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m \in \cclos{N}, 0 \leq m \leq n $
            то \[ \lb X \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m \rb \gderiv_G \lb X \rc Y \rb \lb Y \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m \rb \]
        \item Ако $ X \lc Y \in \cclos{N}, Y \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m \in \cclos{N}, 0 \leq m \leq n $
            то \[ \lb X \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m \rb \gderiv_G \lb Y \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m \rb \lb X \lc Y \rb \]
    \end{itemize}
  \end{frame}

  \begin{frame}{Пример}
    Ще построим проста граматика $G = \langle \Sigma, N, S, f, n \rangle$
    която генерира \code{cities in Germany}:

    \begin{align*}
        \Sigma \defeq& \{ cities, in, Germany \} \\
        N \defeq& \{ GSet \} \\
        S \defeq& GSet \\
        f(x) \defeq&
            \begin{cases*}
                \{ GSet \},& x = cities \\
                \{ GSet \},& x = Germany \\
                \{ GSet \lc GSet \rc GSet \},& x = in \\
            \end{cases*} \\
        n \defeq& 1 \\
    \end{align*}
  \end{frame}

  \begin{frame}{Примерен извод}
    \begin{center}
        \begin{tabular}{c}
            $\underline{\lb GSet \rb}$ \\ $\gstep$ \\
            $\lb GSet \rb \underline{\lb GSet \lc GSet \rb}$ \\ $\gstep$ \\
            $\underline{\lb GSet \rb} \lb GSet \lc GSet \rc GSet \rb \lb GSet \rb$ \\ $\gstep$ \\
            $cities \sq \underline{\lb GSet \lc GSet \rc GSet \rb} \lb GSet \rb$ \\ $\gstep$ \\
            $cities \sq in \sq \underline{\lb GSet \rb}$ \\ $\gstep$ \\
            $cities \sq in \sq Germany$ \\
        \end{tabular}
    \end{center}
  \end{frame}

  \begin{frame}{Свойство}
    Всяка КГ $G = \langle \Sigma, N, S, f, n \rangle$ е еквивалентна на
    (безкрайна) контекстно свободна граматика
    $G^C = \langle \Sigma, \lb \cclos{N} \rb, R, \lb S \rb \rangle$.

    Освен това, имайки извод $\mu: \alpha_1 \gstep ... \gstep \alpha_r$.
    Можем да построим специална \textbf{крайна} контекстно-свободна граматика
    $G_\mu^C = \langle \Sigma, \lb \catsin{\mu} \rb, \restr{R}{\lb \catsin{\mu} \rb}, \lb S \rb \rangle$,
    в която $\mu$ е валиден извод и всички нейни изводи са изводи и в $G$.

    \begin{proof}
        Дефинициите на $\gstep$ за $G$ и за $G^C$ съвпадат.
    \end{proof}
  \end{frame}

  \begin{frame}{CYK за КГ}
    По даден вход (дума) строим строим множество $P$ от тройки
    $(X, i, j)$, $X \in \cclos{N}, 1 \leq i \leq j \leq k$ индуктивно,
    опитвайки се да получим
    $(S, 1, k)$.

    \begin{enumerate}
    \label{cyk:rules}
        \item Ако $X \in f(w_i)$, то $(X, i, i) \in P$.
        \item Ако $(X \rc Y, i, p) \in P, (Y \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m, p + 1, j) \in P$,
            то $(X \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m, i, j) \in P$.
        \item Ако $(X \lc Y, p + 1, j) \in P, (Y \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m, i, p) \in P$,
            то $(X \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m, i, j) \in P$.
    \end{enumerate}
  \end{frame}

  \begin{frame}{Коректност}
    \begin{enumerate}
        \item Ако $X \in f(w_i)$, то $(X, i, i) \in P$.
        \item Ако $(X \rc Y, i, p) \in P, (Y \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m, p + 1, j) \in P$,
            то $(X \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m, i, j) \in P$.
        \item Ако $(X \lc Y, p + 1, j) \in P, (Y \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m, i, p) \in P$,
            то $(X \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m, i, j) \in P$.
    \end{enumerate}

    \begin{equation}\label{eq:left}
        (X, i, j) \in P \implies \lb X \rb \gsteps w_i ... w_j
    \end{equation}
  \end{frame}
  \begin{frame}{Пълнота}
    \begin{enumerate}
        \item Ако $X \in f(w_i)$, то $(X, i, i) \in P$.
        \item Ако $(X \rc Y, i, p) \in P, (Y \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m, p + 1, j) \in P$,
            то $(X \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m, i, j) \in P$.
        \item Ако $(X \lc Y, p + 1, j) \in P, (Y \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m, i, p) \in P$,
            то $(X \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m, i, j) \in P$.
    \end{enumerate}
    \begin{equation}\label{eq:right}
        \lb X \rb \gsteps w_i ... w_j \implies (X, i, j) \in P
    \end{equation}
  \end{frame}

  \begin{frame}{Семантика в КГ}
    Дефинираме $\typeoff : \cclos{N} \fun \tclos{\Theta}$ като:
    \[\typeof{\lp X \mc Y \rp} \defeq  \typeof{Y} \tot \typeof{X}\].

    По дадена КГ $ G = \langle \Sigma, N, S, f, n \rangle $, функцията
    \[ \psi : \{ (a, X) \mid a \in \Sigma, X \in f(a) \} \fun 2^{\plambda{\Theta}{C}} \]
    ще наричаме \emph{семантична функция} за $G$.
  \end{frame}

  \begin{frame}{Семантика в КГ: базов случай}
    \begin{center}
        \begin{tikzpicture}[node distance=1mm,sibling distance=1cm]
            \Tree[
                .\node(outtop){$X$};
                    \edge[very thick];
                    [ .\node(in){$a$};
                    ]
            ]
            \node[boxcolb,fit=(outtop)(in)](outbox){};
            \node[right=of outbox,text=\boxtextb](outlabel){$T$};
        \end{tikzpicture}
    \end{center}
    \[ X \in f(a) \]
    \hrule
    \[ sem_{\psi}(T) = \psi(a, X). \]
  \end{frame}

  \begin{frame}{Семантика в КГ: десен случай}
    \begin{center}
      \begin{tikzpicture}[node distance=1mm,sibling distance=1cm]
        \Tree[
        .\node(outtop){$X \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m$};
        \edge[very thick];
        [ .\node(intopl){$X \rc Y$};
        \edge[roof];
        [ .\node(inbotl){$\alpha$}; ]
        ]
        [ .\node(intopr){$Y \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m$};
        \edge[roof];
        [ .\node(inbotr){$\beta$}; ]
        ]
        ]
        \node[boxcola,fit=(intopl)(inbotl)](inboxl){};
        \node[left=of inboxl,text=\boxtexta](inlabell){$T_1$};

        \node[boxcola,fit=(intopr)(inbotr)](inboxr){};
        \node[right=of inboxr,text=\boxtexta](inlabelr){$T_2$};

        \node[boxcolb,fit=(outtop)(inbotl)(inboxl)(inboxr)(inlabell)(inlabelr)](outbox){};
        \node[right=of outbox,text=\boxtextb](outlabel){$T$};
      \end{tikzpicture}
    \end{center}

    \hrule

    \[
      \begin{split}
        sem_{\psi}(T) =& \{
        \lambda z_m {:} \typeof{Z_m}, z_{m - 1} {:} \typeof{Z_{m - 1}}, ..., z_1 {:} \typeof{Z_1} \abstr
        M ( N z_m z_{m - 1} ... z_1 ) \\
        & \quad \mid M \in sem_{\psi}(T_1), N \in sem_{\psi}(T_2) \} \\
      \end{split}
    \]

    за свежи
    $z_1 ... z_m \in \lvars \setminus \big(\fv{sem_{\psi}(T_1)} \cup \fv{sem_{\psi}(T_2)}\big)$.
  \end{frame}

  \begin{frame}{Консистентност на семантична функция с контекст}
    Семантична функция $\psi$ е консистентна с контекст $\Gamma$, когато
    \[
        \forall a, X: M \in \psi(a, X) \implies \Gamma \vdash M : \typeof{X}.
    \]

    Ако $\psi$ е консистентна с $\Gamma$, то за всяко валидно дърво на извод
    $T$:
    \[
        M \in sem_{\psi}(T) \implies \Gamma \vdash M : \typeof{root(T)}
    \]
  \end{frame}

  \begin{frame}{Разширения на КГ}
    \begin{itemize}
      \item Ограничение на правилата
      \item Модалности
      \item Повдигане на типове
      \item Типови променливи
      \item Equification на категории
      \item Семантика на подтипове
    \end{itemize}
  \end{frame}

  \begin{frame}{Модалности}
    \begin{center}
      \begin{tikzpicture}
        \node[main node] (1) {$\modstar$};
        \node[main node] (2) [below left = 1cm and 1.5cm of 1]  {$\modr$};
        \node[main node] (3) [below right = 1cm and 1.5cm of 1] {$\modx$};
        \node[main node] (4) [below = 2cm of 1] {$\moddot$};

        \path[draw,thick]
        (1) edge node {} (2)
        (1) edge node {} (3)
        (2) edge node {} (4)
        (3) edge node {} (4);
      \end{tikzpicture}
    \end{center}
  \end{frame}

  \begin{frame}{Модалности}
    \begin{itemize}
      \item ``Application''
        \[ \lb X \rb \gderiv \lb X \rci{\mu} Y \rb \lb Y \rb \]
        \[ \lb X \rb \gderiv \lb Y \rb \lb X \lci{\mu} Y \rb \]
        където $\mu \less \modstar$ (т.е. за всяко $\mu$).
      \item ``Harmonic composition''
        \[ \lb X \rci{\eta} Z_1 \mci{2} Z_2 ... \mci{m} Z_m \rb \gderiv \lb X \rci{\mu} Y \rb \lb Y \rci{\nu} Z_1 \mci{2} Z_2 ... \mci{m} Z_m \rb \]
        \[ \lb X \lci{\eta} Z_1 \mci{2} Z_2 ... \mci{m} Z_m \rb \gderiv \lb Y \lci{\mu} Z_1 \mci{2} Z_2 ... \mci{m} Z_m \rb \lb X \lci{\nu} Y \rb \]
        където $\mu \less \modr, \nu \less \modr, \eta = \mu \meet \nu$.
      \item ``Crossing composition''
        \[ \lb X \lci{\eta} Z_1 \mci{2} Z_2 ... \mci{m} Z_m \rb \gderiv \lb X \rci{\mu} Y \rb \lb Y \lci{\nu} Z_1 \mci{2} Z_2 ... \mci{m} Z_m \rb \]
        \[ \lb X \rci{\eta} Z_1 \mci{2} Z_2 ... \mci{m} Z_m \rb \gderiv \lb Y \rci{\mu} Z_1 \mci{2} Z_2 ... \mci{m} Z_m \rb \lb X \lci{\nu} Y \rb \]
        където $\mu \less \modx, \nu \less \modx, \eta = \mu \meet \nu$.
    \end{itemize}
  \end{frame}

  \begin{frame}{Модалности: пример}
    \gramshort{
      \gramrow{small}{ GSet \rc GSet }{}
      \gramrow{cities}{ GSet }{}
      \gramrow{in}{ GSet \lc GSet \rc GSet }{}
      \gramrow{Russia}{ GSet }{}
    }

    \begin{center}
      \begin{minipage}{0.5\textwidth}
        \autoscaledtree{.{$GSet$}
          [ .{$GSet$}
          [ .{$GSet \rc GSet$} [ .{$small$} ] ]
          [ .{$GSet$} [ .{$cities$} ] ]
          ]
          [ .{$GSet \lc GSet$}
          [ .{$GSet \lc GSet \rc GSet$} [ .{$in$} ] ]
          [ .{$GSet$} [ .{$Russia$} ] ]
          ]
        }
      \end{minipage}%
      \begin{minipage}{0.5\textwidth}
        \autoscaledtree{.{$GSet$}
          [ .{$GSet$} [ .{$cities$} ] ]
          [ .{$GSet \lc GSet$}
          [ .{$GSet \rc GSet$} [ .{$small$} ] ]
          [ .{$GSet \lc GSet$}
          [ .{$GSet \lc GSet \rc GSet$} [ .{$in$} ] ]
          [ .{$GSet$} [ .{$Russia$} ] ]
          ]
          ]
        }
      \end{minipage}
    \end{center}
  \end{frame}

  \begin{frame}{Модалности: пример}
    \gramshort{
      \gramrow{small}{ GSet \rci{\modr} GSet }{}
      \gramrow{cities}{ GSet }{}
      \gramrow{in}{ GSet \lc GSet \rc GSet }{}
      \gramrow{Russia}{ GSet }{}
    }

    \begin{center}
      \begin{minipage}{0.5\textwidth}
        \autoscaledtree{.{$GSet$}
          [ .{$GSet$}
          [ .{$GSet \rci{\modr} GSet$} [ .{$small$} ] ]
          [ .{$GSet$} [ .{$cities$} ] ]
          ]
          [ .{$GSet \lc GSet$}
          [ .{$GSet \lc GSet \rc GSet$} [ .{$in$} ] ]
          [ .{$GSet$} [ .{$Russia$} ] ]
          ]
        }
      \end{minipage}%
    \end{center}
  \end{frame}

  \begin{frame}{Категорийни променливи}
    Категорийно затваряне с променливи:
    \begin{enumerate}
        \item \label{cvar:atomic} $A \in \tau \implies A \in \cclos{\tau}$
        \item \label{cvar:right}  $X, Y \in \cclos{\tau} \implies \lp X \rc Y \rp \in \cclos{\tau}$
        \item \label{cvar:left}   $X, Y \in \cclos{\tau} \implies \lp X \lc Y \rp \in \cclos{\tau}$
        \item \label{cvar:var}    $\alpha \in \cvars \implies \alpha \in \cclos{\tau}$
    \end{enumerate}
    Субституция:
    \[
        \subst{Z}{\alpha}{W} =
        \begin{cases*}
            Z ,& $Z \in \tau$ \\
            \lp \subst{X}{\alpha}{W} \mc \subst{Y}{\alpha}{W} \rp ,& $Z = \lp X \mc Y \rp$ \\
            \beta ,& $Z = \beta \in \cvars, \beta \neq \alpha$ \\
            W ,& $Z = \alpha$ \\
        \end{cases*}
    \]
    за $Z \in \cclos{\tau}, W \in \cclos{\tau}, \alpha \in \cvars$
  \end{frame}

  \begin{frame}{Категорийни променливи: извод}
    \begin{center}
        \begin{tikzpicture}[node distance=1mm]
            \Tree[
                .\node(outtop){$\subst{X}{a}{Y}$};
                    \edge[very thick];
                    [ .\node(intop){$X$};
                        \edge[roof];
                        [ .\node(inbot){$\alpha$}; ]
                    ]
            ]
            \node[boxcola,fit=(intop)(inbot)](inbox){};
            \node[right=of inbox,text=\boxtexta](inlabel){$T'$};

            \node[boxcolb,fit=(outtop)(inbot)(inbox)(inlabel)](outbox){};
            \node[right=of outbox,text=\boxtextb](outlabel){$T$};
        \end{tikzpicture}
    \end{center}

    \hrule
    \begin{align*}
        sem_{\psi}(T) &= \{ \subst{M}{\typeof{a}}{Y} \mid M \in sem_{\psi}(T') \} \\
    \end{align*}
  \end{frame}

  \begin{frame}{Повдигане на типове}
    \begin{center}
        \tree{.{$\alpha \rci{i} \lp \alpha \lci{i} X \rp$} \edge[very thick]; {$X$} }
            ( Forward type-raising )
        \tree{.{$\alpha \lci{i} \lp \alpha \rci{i} X \rp$} \edge[very thick]; {$X$} }
            ( Backward type-raising )
    \end{center}
  \end{frame}

  \begin{frame}{Повдигане на типове: семантика}
    \begin{center}
        \begin{tikzpicture}[node distance=1mm]
            \Tree[
                .\node(outtop){$\alpha \rci{i} \lp \alpha \lci{i} X \rp$};
                    \edge[very thick];
                    [ .\node(intop){$X$};
                        \edge[roof];
                        [ .\node(inbot){$\alpha$}; ]
                    ]
            ]
            \node[boxcola,fit=(intop)(inbot)](inbox){};
            \node[right=of inbox,text=\boxtexta](inlabel){$T'$};

            \node[boxcolb,fit=(outtop)(inbot)(inbox)(inlabel)](outbox){};
            \node[right=of outbox,text=\boxtextb](outlabel){$T$};
        \end{tikzpicture}
        \hspace{2cm}
        \begin{tikzpicture}[node distance=1mm]
            \Tree[
                .\node(outtop){$\alpha \lci{i} \lp \alpha \rci{i} X \rp$};
                    \edge[very thick];
                    [ .\node(intop){$X$};
                        \edge[roof];
                        [ .\node(inbot){$\alpha$}; ]
                    ]
            ]
            \node[boxcola,fit=(intop)(inbot)](inbox){};
            \node[right=of inbox,text=\boxtexta](inlabel){$T'$};

            \node[boxcolb,fit=(outtop)(inbot)(inbox)(inlabel)](outbox){};
            \node[right=of outbox,text=\boxtextb](outlabel){$T$};
        \end{tikzpicture}
    \end{center}

    \[ sem_{\psi}(T) = \{ \lambda f {:} ( X \tot \alpha ) \abstr f M \mid M \in sem_{\psi}(T') \} \]
  \end{frame}

  \begin{frame}{Повдигане на типове: пример}
    \begin{minipage}{0.5\textwidth}
    \gramshort{
        \gramrow{cities}{ GSet }{}
        \gramrow{villages}{ GSet }{}
        \gramrow{Finland}{ GSet }{}
    }
    \end{minipage}%
    \begin{minipage}{0.5\textwidth}
    \gramshort{
        \gramrow{and}{ \alpha \lc \alpha \rc \alpha }{}
        \gramrow{in}{ GSet \lc GSet \rc GSet }{}
        \gramrow{near}{ GSet \lc GSet \rc GSet }{}
      }
    \end{minipage}

    \scaledtree{0.9}{
        .{$GSet$}
            \edge[very thick];
            [ .{$GSet$}
                [ .{$GSet$}
                    [ .{$cities$} ]
                ]
                [ .{$GSet \lc GSet$}
                    [ .{$GSet \lc GSet \rc GSet$}
                        [ .{$\alpha \lc \alpha \rc \alpha$} [ .{$and$} ] ]
                    ]
                    [ .{$GSet$}
                        [ .{$villages$} ]
                    ]
                ]
            ]
            [ .{$GSet \lc GSet$}
                [ .{$GSet \lc GSet \rc GSet$}
                    [ .{$in$} ]
                ]
                [ .{$GSet$}
                    [ .{$Finland$} ]
                ]
            ]
    }
  \end{frame}

  \begin{frame}{Повдигане на типове: пример}
    \begin{minipage}{0.5\textwidth}
    \gramshort{
        \gramrow{cities}{ GSet }{}
        \gramrow{villages}{ GSet }{}
        \gramrow{Finland}{ GSet }{}
    }
    \end{minipage}%
    \begin{minipage}{0.5\textwidth}
    \gramshort{
        \gramrow{and}{ \alpha \lc \alpha \rc \alpha }{}
        \gramrow{in}{ GSet \lc GSet \rc GSet }{}
        \gramrow{near}{ GSet \lc GSet \rc GSet }{}
      }
    \end{minipage}
    \code{cities in and villages near Finland}?
  \end{frame}
  \begin{frame}{Повдигане на типове: пример}
    \begin{minipage}{0.5\textwidth}
    \gramshort{
        \gramrow{cities}{ GSet }{}
        \gramrow{villages}{ GSet }{}
        \gramrow{Finland}{ GSet }{}
    }
    \end{minipage}%
    \begin{minipage}{0.5\textwidth}
    \gramshort{
        \gramrow{and}{ \alpha \lc \alpha \rc \alpha }{}
        \gramrow{in}{ GSet \lc GSet \rc GSet }{}
        \gramrow{near}{ GSet \lc GSet \rc GSet }{}
      }
    \end{minipage}
    \scaledtree{0.6}{
        .{$GSet$}
        [ .{$GSet \rc GSet$}
            [ .{$ GSet \rc GSet$}
                [ .{$GSet \rc \lp GSet \lc GSet \rp$}
                    [ .{$\alpha \rc \lp \alpha \lc GSet \rp$} [ .{$GSet$} [ .{$cities$} ] ] ]
                ]
                [ .{$GSet \lc GSet \rc GSet$} [ .{$in$} ]
                ]
            ]
            [ .{$ \lp GSet \rc GSet \rp \lc \lp GSet \rc GSet \rp$}
                [ .{$\lp GSet \rc GSet \rp \lc \lp GSet \rc GSet \rp \rc \lp GSet \rc GSet \rp$}
                    [ .{$\alpha \lc \alpha \rc \alpha$} [ .{$and$} ] ]
                ]
                    [ .{$GSet \rc GSet$}
                    [ .{$GSet \rc \lp GSet \lc GSet \rp$}
                        [ .{$\alpha \rc \lp \alpha \lc GSet \rp$} [ .{$GSet$} [ .{$villages$} ] ] ]
                    ]
                    [ .{$GSet \lc GSet \rc GSet$} [ .{$near$} ]
                    ]
                ]
            ]
        ]
        [ .{$ GSet$} [ .{$Finland$} ] ]
      }
  \end{frame}

  \begin{frame}{Подтипове в КГ}
    Релация за подтипове върху атомарни категории:
    \[ U(X, Y) \defiff \typeof{Y} \less \typeof{X} \]

    Контравариантно затваряне на $U$:
    \begin{itemize}
        \item $X \in N \land Y \in N \land U(X, Y) \implies \overline{U}(X, Y)$
        \item $X = (W' \mc Z') \land Y = (W'' \mc Z'') \land \overline{U}(W'', W')
        \land \overline{U}(Z', Z'')\implies \overline{U}(X, Y)$
    \end{itemize}
  \end{frame}

  \begin{frame}{Подтипове в КГ: изводи}
    \begin{itemize}
        \item Ако $ a \in \Sigma, X \in f(a) $, то \[ \lb X \rb \gderiv a \]
        \item Ако $ X \rc Y' \in \cclos{N}, Y'' \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m \in \cclos{N}, 0 \leq m \leq n $
            и $\overline{U}(Y', Y'')$, \\
            то \[ \lb X \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m \rb \gderiv \lb X \rc Y \rb \lb Y \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m \rb \]
        \item Ако $ X \lc Y' \in \cclos{N}, Y'' \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m \in \cclos{N}, 0 \leq m \leq n $
            и $\overline{U}(Y', Y'')$, \\
            то \[ \lb X \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m \rb \gderiv \lb Y \mci{1} Z_1 \mci{2} Z_2 ... \mci{m} Z_m \rb \lb X \lc Y \rb \]
    \end{itemize}
  \end{frame}

  \section{Категорийни граматики върху Minipass}
  \begin{frame}{Език за дефиниране на КГ}
    \begin{itemize}
      \item Дефиниране на подтипове
      \item Дефиниране на термове
      \item Специфициране на начална категория
      \item Категорийни правила
    \end{itemize}
  \end{frame}
  \section{Резултат}
  \begin{frame}{Резултат}няколко слайда тук\end{frame}

\end{document}
